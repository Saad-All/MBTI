/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/[locale]/assessment/results/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cam112%5C%5COneDrive%5C%5C%D8%B3%D8%B7%D8%AD%20%D8%A7%D9%84%D9%85%D9%83%D8%AA%D8%A8%5C%5CClients%5C%5CMBTI%5C%5Csrc%5C%5Capp%5C%5C%5Blocale%5D%5C%5Cassessment%5C%5Cresults%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cam112%5C%5COneDrive%5C%5C%D8%B3%D8%B7%D8%AD%20%D8%A7%D9%84%D9%85%D9%83%D8%AA%D8%A8%5C%5CClients%5C%5CMBTI%5C%5Csrc%5C%5Capp%5C%5C%5Blocale%5D%5C%5Cassessment%5C%5Cresults%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/[locale]/assessment/results/page.tsx */ \"(app-pages-browser)/./src/app/[locale]/assessment/results/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDYW0xMTIlNUMlNUNPbmVEcml2ZSU1QyU1QyVEOCVCMyVEOCVCNyVEOCVBRCUyMCVEOCVBNyVEOSU4NCVEOSU4NSVEOSU4MyVEOCVBQSVEOCVBOCU1QyU1Q0NsaWVudHMlNUMlNUNNQlRJJTVDJTVDc3JjJTVDJTVDYXBwJTVDJTVDJTVCbG9jYWxlJTVEJTVDJTVDYXNzZXNzbWVudCU1QyU1Q3Jlc3VsdHMlNUMlNUNwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLHNOQUE2SSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzBiMTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFxhbTExMlxcXFxPbmVEcml2ZVxcXFzYs9i32K0g2KfZhNmF2YPYqtioXFxcXENsaWVudHNcXFxcTUJUSVxcXFxzcmNcXFxcYXBwXFxcXFtsb2NhbGVdXFxcXGFzc2Vzc21lbnRcXFxccmVzdWx0c1xcXFxwYWdlLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cam112%5C%5COneDrive%5C%5C%D8%B3%D8%B7%D8%AD%20%D8%A7%D9%84%D9%85%D9%83%D8%AA%D8%A8%5C%5CClients%5C%5CMBTI%5C%5Csrc%5C%5Capp%5C%5C%5Blocale%5D%5C%5Cassessment%5C%5Cresults%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzP2RmNmMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0EsMERBQTBELFlBQVk7QUFDdEUsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanM/NjdlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUkMihzdWJzY3JpYmUsIGdldFNuYXBzaG90KSB7XG4gICAgICBkaWRXYXJuT2xkMThBbHBoYSB8fFxuICAgICAgICB2b2lkIDAgPT09IFJlYWN0LnN0YXJ0VHJhbnNpdGlvbiB8fFxuICAgICAgICAoKGRpZFdhcm5PbGQxOEFscGhhID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiWW91IGFyZSB1c2luZyBhbiBvdXRkYXRlZCwgcHJlLXJlbGVhc2UgYWxwaGEgb2YgUmVhY3QgMTggdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHVzZVN5bmNFeHRlcm5hbFN0b3JlLiBUaGUgdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSB0byBhIG5ld2VyIHByZS1yZWxlYXNlLlwiXG4gICAgICAgICkpO1xuICAgICAgdmFyIHZhbHVlID0gZ2V0U25hcHNob3QoKTtcbiAgICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgICAgdmFyIGNhY2hlZFZhbHVlID0gZ2V0U25hcHNob3QoKTtcbiAgICAgICAgb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCkpO1xuICAgICAgfVxuICAgICAgY2FjaGVkVmFsdWUgPSB1c2VTdGF0ZSh7XG4gICAgICAgIGluc3Q6IHsgdmFsdWU6IHZhbHVlLCBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QgfVxuICAgICAgfSk7XG4gICAgICB2YXIgaW5zdCA9IGNhY2hlZFZhbHVlWzBdLmluc3QsXG4gICAgICAgIGZvcmNlVXBkYXRlID0gY2FjaGVkVmFsdWVbMV07XG4gICAgICB1c2VMYXlvdXRFZmZlY3QoXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90O1xuICAgICAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VVcGRhdGUoeyBpbnN0OiBpbnN0IH0pO1xuICAgICAgICB9LFxuICAgICAgICBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdXG4gICAgICApO1xuICAgICAgdXNlRWZmZWN0KFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJiBmb3JjZVVwZGF0ZSh7IGluc3Q6IGluc3QgfSk7XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlVXBkYXRlKHsgaW5zdDogaW5zdCB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgW3N1YnNjcmliZV1cbiAgICAgICk7XG4gICAgICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gICAgICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuICAgICAgaW5zdCA9IGluc3QudmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICAgICAgcmV0dXJuICFvYmplY3RJcyhpbnN0LCBuZXh0VmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpIHtcbiAgICAgIHJldHVybiBnZXRTbmFwc2hvdCgpO1xuICAgIH1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KEVycm9yKCkpO1xuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgICAgIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXMsXG4gICAgICB1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlLFxuICAgICAgdXNlRWZmZWN0ID0gUmVhY3QudXNlRWZmZWN0LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0ID0gUmVhY3QudXNlTGF5b3V0RWZmZWN0LFxuICAgICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWUsXG4gICAgICBkaWRXYXJuT2xkMThBbHBoYSA9ICExLFxuICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMSxcbiAgICAgIHNoaW0gPVxuICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93IHx8XG4gICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgfHxcbiAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG4gICAgICAgICAgPyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxXG4gICAgICAgICAgOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyO1xuICAgIGV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmUgPVxuICAgICAgdm9pZCAwICE9PSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSA/IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlIDogc2hpbTtcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChFcnJvcigpKTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      shim = __webpack_require__(/*! use-sync-external-store/shim */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = shim.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLEtBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBTztBQUMvQixhQUFhLG1CQUFPLENBQUMsOEdBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0NBQXdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanM/MzZjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KEVycm9yKCkpO1xuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgICAgIHNoaW0gPSByZXF1aXJlKFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbVwiKSxcbiAgICAgIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXMsXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHNoaW0udXNlU3luY0V4dGVybmFsU3RvcmUsXG4gICAgICB1c2VSZWYgPSBSZWFjdC51c2VSZWYsXG4gICAgICB1c2VFZmZlY3QgPSBSZWFjdC51c2VFZmZlY3QsXG4gICAgICB1c2VNZW1vID0gUmVhY3QudXNlTWVtbyxcbiAgICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdC51c2VEZWJ1Z1ZhbHVlO1xuICAgIGV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmdW5jdGlvbiAoXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBnZXRTbmFwc2hvdCxcbiAgICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgICAgc2VsZWN0b3IsXG4gICAgICBpc0VxdWFsXG4gICAgKSB7XG4gICAgICB2YXIgaW5zdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICAgIGlmIChudWxsID09PSBpbnN0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgdmFyIGluc3QgPSB7IGhhc1ZhbHVlOiAhMSwgdmFsdWU6IG51bGwgfTtcbiAgICAgICAgaW5zdFJlZi5jdXJyZW50ID0gaW5zdDtcbiAgICAgIH0gZWxzZSBpbnN0ID0gaW5zdFJlZi5jdXJyZW50O1xuICAgICAgaW5zdFJlZiA9IHVzZU1lbW8oXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jdGlvbiBtZW1vaXplZFNlbGVjdG9yKG5leHRTbmFwc2hvdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNNZW1vKSB7XG4gICAgICAgICAgICAgIGhhc01lbW8gPSAhMDtcbiAgICAgICAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgICAgICAgICAgbmV4dFNuYXBzaG90ID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcbiAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gaXNFcXVhbCAmJiBpbnN0Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBpbnN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIG5leHRTbmFwc2hvdCkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIChtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uID0gbWVtb2l6ZWRTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAob2JqZWN0SXMobWVtb2l6ZWRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KSlcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICB2YXIgbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBpc0VxdWFsICYmIGlzRXF1YWwoY3VycmVudFNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbikpXG4gICAgICAgICAgICAgIHJldHVybiAobWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdCksIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgICAgICAgcmV0dXJuIChtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaGFzTWVtbyA9ICExLFxuICAgICAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCxcbiAgICAgICAgICAgIG1lbW9pemVkU2VsZWN0aW9uLFxuICAgICAgICAgICAgbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCA9XG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QgPyBudWxsIDogZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IoZ2V0U25hcHNob3QoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVsbCA9PT0gbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKG1heWJlR2V0U2VydmVyU25hcHNob3QoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgICAgIFtnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsXVxuICAgICAgKTtcbiAgICAgIHZhciB2YWx1ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgaW5zdFJlZlswXSwgaW5zdFJlZlsxXSk7XG4gICAgICB1c2VFZmZlY3QoXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpbnN0Lmhhc1ZhbHVlID0gITA7XG4gICAgICAgICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBbdmFsdWVdXG4gICAgICApO1xuICAgICAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgJiZcbiAgICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChFcnJvcigpKTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0TUFBOEU7QUFDaEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanM/OTNiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/with-selector.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHdPQUE0RjtBQUM5RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzPzY3MTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/[locale]/assessment/results/page.tsx":
/*!******************************************************!*\
  !*** ./src/app/[locale]/assessment/results/page.tsx ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ResultsPage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _lib_stores_assessment_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/stores/assessment-store */ \"(app-pages-browser)/./src/lib/stores/assessment-store.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n/**\r\n * General results router - redirects to methodology-specific results pages\r\n * This ensures backward compatibility while routing to consciousness-focused results for SAIS\r\n */ function ResultsPage(param) {\n    let { params: { locale } } = param;\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const { sessionId, selectedFormat } = (0,_lib_stores_assessment_store__WEBPACK_IMPORTED_MODULE_3__.useAssessmentStore)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Don't process if no session\n        if (!sessionId) {\n            console.error(\"No session ID found, redirecting to home\");\n            router.push(\"/\".concat(locale));\n            return;\n        }\n        // Route to methodology-specific results pages\n        switch(selectedFormat){\n            case \"sais\":\n                // Redirect to consciousness-focused SAIS results\n                router.push(\"/\".concat(locale, \"/results/sais\"));\n                break;\n            case \"scenarios\":\n            case \"traits\":\n                // For now, redirect to standard results (to be implemented later)\n                console.log(\"\".concat(selectedFormat, \" results not yet implemented, staying on general results\"));\n                // TODO: Implement standard results page for scenarios/traits\n                router.push(\"/\".concat(locale)); // Temporary redirect to home\n                break;\n            default:\n                console.error(\"Unknown assessment format:\", selectedFormat);\n                router.push(\"/\".concat(locale));\n                break;\n        }\n    }, [\n        sessionId,\n        selectedFormat,\n        locale,\n        router\n    ]);\n    // Loading state while redirecting\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"text-center\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\am112\\\\OneDrive\\\\سطح المكتب\\\\Clients\\\\MBTI\\\\src\\\\app\\\\[locale]\\\\assessment\\\\results\\\\page.tsx\",\n                    lineNumber: 55,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-gray-600\",\n                    children: \"جاري تحضير النتائج...\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\am112\\\\OneDrive\\\\سطح المكتب\\\\Clients\\\\MBTI\\\\src\\\\app\\\\[locale]\\\\assessment\\\\results\\\\page.tsx\",\n                    lineNumber: 56,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\am112\\\\OneDrive\\\\سطح المكتب\\\\Clients\\\\MBTI\\\\src\\\\app\\\\[locale]\\\\assessment\\\\results\\\\page.tsx\",\n            lineNumber: 54,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\am112\\\\OneDrive\\\\سطح المكتب\\\\Clients\\\\MBTI\\\\src\\\\app\\\\[locale]\\\\assessment\\\\results\\\\page.tsx\",\n        lineNumber: 53,\n        columnNumber: 5\n    }, this);\n}\n_s(ResultsPage, \"rcC5/zWnjU5i5qFxYWIIjeIIbws=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter,\n        _lib_stores_assessment_store__WEBPACK_IMPORTED_MODULE_3__.useAssessmentStore\n    ];\n});\n_c = ResultsPage;\nvar _c;\n$RefreshReg$(_c, \"ResultsPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvW2xvY2FsZV0vYXNzZXNzbWVudC9yZXN1bHRzL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRWtDO0FBQ1U7QUFDdUI7QUFNbkU7OztDQUdDLEdBQ2MsU0FBU0csWUFBWSxLQUF3QztRQUF4QyxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRSxFQUFvQixHQUF4Qzs7SUFDbEMsTUFBTUMsU0FBU0wsMERBQVNBO0lBQ3hCLE1BQU0sRUFBRU0sU0FBUyxFQUFFQyxjQUFjLEVBQUUsR0FBR04sZ0ZBQWtCQTtJQUV4REYsZ0RBQVNBLENBQUM7UUFDUiw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDTyxXQUFXO1lBQ2RFLFFBQVFDLEtBQUssQ0FBQztZQUNkSixPQUFPSyxJQUFJLENBQUMsSUFBVyxPQUFQTjtZQUNoQjtRQUNGO1FBRUEsOENBQThDO1FBQzlDLE9BQVFHO1lBQ04sS0FBSztnQkFDSCxpREFBaUQ7Z0JBQ2pERixPQUFPSyxJQUFJLENBQUMsSUFBVyxPQUFQTixRQUFPO2dCQUN2QjtZQUVGLEtBQUs7WUFDTCxLQUFLO2dCQUNILGtFQUFrRTtnQkFDbEVJLFFBQVFHLEdBQUcsQ0FDVCxHQUFrQixPQUFmSixnQkFBZTtnQkFFcEIsNkRBQTZEO2dCQUM3REYsT0FBT0ssSUFBSSxDQUFDLElBQVcsT0FBUE4sVUFBVyw2QkFBNkI7Z0JBQ3hEO1lBRUY7Z0JBQ0VJLFFBQVFDLEtBQUssQ0FBQyw4QkFBOEJGO2dCQUM1Q0YsT0FBT0ssSUFBSSxDQUFDLElBQVcsT0FBUE47Z0JBQ2hCO1FBQ0o7SUFDRixHQUFHO1FBQUNFO1FBQVdDO1FBQWdCSDtRQUFRQztLQUFPO0lBRTlDLGtDQUFrQztJQUNsQyxxQkFDRSw4REFBQ087UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ0Q7WUFBSUMsV0FBVTs7OEJBQ2IsOERBQUNEO29CQUFJQyxXQUFVOzs7Ozs7OEJBQ2YsOERBQUNDO29CQUFFRCxXQUFVOzhCQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJckM7R0E3Q3dCWDs7UUFDUEYsc0RBQVNBO1FBQ2NDLDRFQUFrQkE7OztLQUZsQ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9bbG9jYWxlXS9hc3Nlc3NtZW50L3Jlc3VsdHMvcGFnZS50c3g/YzI4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uXCI7XHJcbmltcG9ydCB7IHVzZUFzc2Vzc21lbnRTdG9yZSB9IGZyb20gXCJAL2xpYi9zdG9yZXMvYXNzZXNzbWVudC1zdG9yZVwiO1xyXG5cclxuaW50ZXJmYWNlIFJlc3VsdHNQYWdlUHJvcHMge1xyXG4gIHBhcmFtczogeyBsb2NhbGU6IHN0cmluZyB9O1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhbCByZXN1bHRzIHJvdXRlciAtIHJlZGlyZWN0cyB0byBtZXRob2RvbG9neS1zcGVjaWZpYyByZXN1bHRzIHBhZ2VzXHJcbiAqIFRoaXMgZW5zdXJlcyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdoaWxlIHJvdXRpbmcgdG8gY29uc2Npb3VzbmVzcy1mb2N1c2VkIHJlc3VsdHMgZm9yIFNBSVNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlc3VsdHNQYWdlKHsgcGFyYW1zOiB7IGxvY2FsZSB9IH06IFJlc3VsdHNQYWdlUHJvcHMpIHtcclxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuICBjb25zdCB7IHNlc3Npb25JZCwgc2VsZWN0ZWRGb3JtYXQgfSA9IHVzZUFzc2Vzc21lbnRTdG9yZSgpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgLy8gRG9uJ3QgcHJvY2VzcyBpZiBubyBzZXNzaW9uXHJcbiAgICBpZiAoIXNlc3Npb25JZCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiTm8gc2Vzc2lvbiBJRCBmb3VuZCwgcmVkaXJlY3RpbmcgdG8gaG9tZVwiKTtcclxuICAgICAgcm91dGVyLnB1c2goYC8ke2xvY2FsZX1gKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJvdXRlIHRvIG1ldGhvZG9sb2d5LXNwZWNpZmljIHJlc3VsdHMgcGFnZXNcclxuICAgIHN3aXRjaCAoc2VsZWN0ZWRGb3JtYXQpIHtcclxuICAgICAgY2FzZSBcInNhaXNcIjpcclxuICAgICAgICAvLyBSZWRpcmVjdCB0byBjb25zY2lvdXNuZXNzLWZvY3VzZWQgU0FJUyByZXN1bHRzXHJcbiAgICAgICAgcm91dGVyLnB1c2goYC8ke2xvY2FsZX0vcmVzdWx0cy9zYWlzYCk7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIFwic2NlbmFyaW9zXCI6XHJcbiAgICAgIGNhc2UgXCJ0cmFpdHNcIjpcclxuICAgICAgICAvLyBGb3Igbm93LCByZWRpcmVjdCB0byBzdGFuZGFyZCByZXN1bHRzICh0byBiZSBpbXBsZW1lbnRlZCBsYXRlcilcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGAke3NlbGVjdGVkRm9ybWF0fSByZXN1bHRzIG5vdCB5ZXQgaW1wbGVtZW50ZWQsIHN0YXlpbmcgb24gZ2VuZXJhbCByZXN1bHRzYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHN0YW5kYXJkIHJlc3VsdHMgcGFnZSBmb3Igc2NlbmFyaW9zL3RyYWl0c1xyXG4gICAgICAgIHJvdXRlci5wdXNoKGAvJHtsb2NhbGV9YCk7IC8vIFRlbXBvcmFyeSByZWRpcmVjdCB0byBob21lXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIGFzc2Vzc21lbnQgZm9ybWF0OlwiLCBzZWxlY3RlZEZvcm1hdCk7XHJcbiAgICAgICAgcm91dGVyLnB1c2goYC8ke2xvY2FsZX1gKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9LCBbc2Vzc2lvbklkLCBzZWxlY3RlZEZvcm1hdCwgbG9jYWxlLCByb3V0ZXJdKTtcclxuXHJcbiAgLy8gTG9hZGluZyBzdGF0ZSB3aGlsZSByZWRpcmVjdGluZ1xyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBiZy1ncmFkaWVudC10by1iciBmcm9tLWJsdWUtNTAgdG8taW5kaWdvLTEwMCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhbmltYXRlLXNwaW4gcm91bmRlZC1mdWxsIGgtMTIgdy0xMiBib3JkZXItYi0yIGJvcmRlci1ibHVlLTYwMCBteC1hdXRvIG1iLTRcIj48L2Rpdj5cclxuICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNjAwXCI+2KzYp9ix2Yog2KrYrdi22YrYsSDYp9mE2YbYqtin2KbYrC4uLjwvcD5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSb3V0ZXIiLCJ1c2VBc3Nlc3NtZW50U3RvcmUiLCJSZXN1bHRzUGFnZSIsInBhcmFtcyIsImxvY2FsZSIsInJvdXRlciIsInNlc3Npb25JZCIsInNlbGVjdGVkRm9ybWF0IiwiY29uc29sZSIsImVycm9yIiwicHVzaCIsImxvZyIsImRpdiIsImNsYXNzTmFtZSIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/[locale]/assessment/results/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/constants/assessment.ts":
/*!*****************************************!*\
  !*** ./src/lib/constants/assessment.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CORE_QUESTIONS_COUNT: function() { return /* binding */ CORE_QUESTIONS_COUNT; },\n/* harmony export */   FORMAT_QUESTIONS: function() { return /* binding */ FORMAT_QUESTIONS; },\n/* harmony export */   PROGRESS_MILESTONES: function() { return /* binding */ PROGRESS_MILESTONES; },\n/* harmony export */   QUESTION_POOLS: function() { return /* binding */ QUESTION_POOLS; },\n/* harmony export */   TOTAL_QUESTIONS: function() { return /* binding */ TOTAL_QUESTIONS; }\n/* harmony export */ });\n/**\r\n * Assessment constants for question counts and format configurations\r\n */ // Core assessment constants\nconst CORE_QUESTIONS_COUNT = 4;\n// Format-specific question counts\nconst FORMAT_QUESTIONS = {\n    scenarios: 12,\n    traits: 16,\n    sais: 12\n};\n// Total questions per format (including core)\nconst TOTAL_QUESTIONS = {\n    scenarios: CORE_QUESTIONS_COUNT + FORMAT_QUESTIONS.scenarios,\n    traits: CORE_QUESTIONS_COUNT + FORMAT_QUESTIONS.traits,\n    sais: CORE_QUESTIONS_COUNT + FORMAT_QUESTIONS.sais // 16\n};\n// Progress milestones\nconst PROGRESS_MILESTONES = {\n    coreComplete: 25,\n    formatSelected: 40,\n    assessmentComplete: 100\n};\n// Question pool identifiers\nconst QUESTION_POOLS = {\n    core: \"core-foundation\",\n    scenarios: \"life-scenarios\",\n    traits: \"personality-traits\",\n    sais: \"sais-methodology\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29uc3RhbnRzL2Fzc2Vzc21lbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVELDRCQUE0QjtBQUNyQixNQUFNQSx1QkFBdUIsRUFBRTtBQUV0QyxrQ0FBa0M7QUFDM0IsTUFBTUMsbUJBQW1CO0lBQzlCQyxXQUFXO0lBQ1hDLFFBQVE7SUFDUkMsTUFBTTtBQUNSLEVBQVc7QUFFWCw4Q0FBOEM7QUFDdkMsTUFBTUMsa0JBQWtCO0lBQzdCSCxXQUFXRix1QkFBdUJDLGlCQUFpQkMsU0FBUztJQUM1REMsUUFBUUgsdUJBQXVCQyxpQkFBaUJFLE1BQU07SUFDdERDLE1BQU1KLHVCQUF1QkMsaUJBQWlCRyxJQUFJLENBQUMsS0FBSztBQUMxRCxFQUFXO0FBRVgsc0JBQXNCO0FBQ2YsTUFBTUUsc0JBQXNCO0lBQ2pDQyxjQUFjO0lBQ2RDLGdCQUFnQjtJQUNoQkMsb0JBQW9CO0FBQ3RCLEVBQVc7QUFFWCw0QkFBNEI7QUFDckIsTUFBTUMsaUJBQWlCO0lBQzVCQyxNQUFNO0lBQ05ULFdBQVc7SUFDWEMsUUFBUTtJQUNSQyxNQUFNO0FBQ1IsRUFBVyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2NvbnN0YW50cy9hc3Nlc3NtZW50LnRzP2FiZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEFzc2Vzc21lbnQgY29uc3RhbnRzIGZvciBxdWVzdGlvbiBjb3VudHMgYW5kIGZvcm1hdCBjb25maWd1cmF0aW9uc1xyXG4gKi9cclxuXHJcbi8vIENvcmUgYXNzZXNzbWVudCBjb25zdGFudHNcclxuZXhwb3J0IGNvbnN0IENPUkVfUVVFU1RJT05TX0NPVU5UID0gNDtcclxuXHJcbi8vIEZvcm1hdC1zcGVjaWZpYyBxdWVzdGlvbiBjb3VudHNcclxuZXhwb3J0IGNvbnN0IEZPUk1BVF9RVUVTVElPTlMgPSB7XHJcbiAgc2NlbmFyaW9zOiAxMixcclxuICB0cmFpdHM6IDE2LFxyXG4gIHNhaXM6IDEyXHJcbn0gYXMgY29uc3Q7XHJcblxyXG4vLyBUb3RhbCBxdWVzdGlvbnMgcGVyIGZvcm1hdCAoaW5jbHVkaW5nIGNvcmUpXHJcbmV4cG9ydCBjb25zdCBUT1RBTF9RVUVTVElPTlMgPSB7XHJcbiAgc2NlbmFyaW9zOiBDT1JFX1FVRVNUSU9OU19DT1VOVCArIEZPUk1BVF9RVUVTVElPTlMuc2NlbmFyaW9zLCAvLyAxNlxyXG4gIHRyYWl0czogQ09SRV9RVUVTVElPTlNfQ09VTlQgKyBGT1JNQVRfUVVFU1RJT05TLnRyYWl0cywgLy8gMjBcclxuICBzYWlzOiBDT1JFX1FVRVNUSU9OU19DT1VOVCArIEZPUk1BVF9RVUVTVElPTlMuc2FpcyAvLyAxNlxyXG59IGFzIGNvbnN0O1xyXG5cclxuLy8gUHJvZ3Jlc3MgbWlsZXN0b25lc1xyXG5leHBvcnQgY29uc3QgUFJPR1JFU1NfTUlMRVNUT05FUyA9IHtcclxuICBjb3JlQ29tcGxldGU6IDI1LCAvLyBBZnRlciA0IGNvcmUgcXVlc3Rpb25zXHJcbiAgZm9ybWF0U2VsZWN0ZWQ6IDQwLCAvLyBBZnRlciBmb3JtYXQgc2VsZWN0aW9uXHJcbiAgYXNzZXNzbWVudENvbXBsZXRlOiAxMDBcclxufSBhcyBjb25zdDtcclxuXHJcbi8vIFF1ZXN0aW9uIHBvb2wgaWRlbnRpZmllcnNcclxuZXhwb3J0IGNvbnN0IFFVRVNUSU9OX1BPT0xTID0ge1xyXG4gIGNvcmU6ICdjb3JlLWZvdW5kYXRpb24nLFxyXG4gIHNjZW5hcmlvczogJ2xpZmUtc2NlbmFyaW9zJyxcclxuICB0cmFpdHM6ICdwZXJzb25hbGl0eS10cmFpdHMnLFxyXG4gIHNhaXM6ICdzYWlzLW1ldGhvZG9sb2d5J1xyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IHR5cGUgQXNzZXNzbWVudEZvcm1hdCA9IGtleW9mIHR5cGVvZiBGT1JNQVRfUVVFU1RJT05TO1xyXG5leHBvcnQgdHlwZSBRdWVzdGlvblBvb2wgPSB0eXBlb2YgUVVFU1RJT05fUE9PTFNba2V5b2YgdHlwZW9mIFFVRVNUSU9OX1BPT0xTXTsiXSwibmFtZXMiOlsiQ09SRV9RVUVTVElPTlNfQ09VTlQiLCJGT1JNQVRfUVVFU1RJT05TIiwic2NlbmFyaW9zIiwidHJhaXRzIiwic2FpcyIsIlRPVEFMX1FVRVNUSU9OUyIsIlBST0dSRVNTX01JTEVTVE9ORVMiLCJjb3JlQ29tcGxldGUiLCJmb3JtYXRTZWxlY3RlZCIsImFzc2Vzc21lbnRDb21wbGV0ZSIsIlFVRVNUSU9OX1BPT0xTIiwiY29yZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/constants/assessment.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/services/OptimizedStorageService.ts":
/*!*****************************************************!*\
  !*** ./src/lib/services/OptimizedStorageService.ts ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OptimizedStorageService: function() { return /* binding */ OptimizedStorageService; },\n/* harmony export */   optimizedStorage: function() { return /* binding */ optimizedStorage; }\n/* harmony export */ });\n/**\r\n * Optimized Storage Service for SAIS Distribution Data\r\n * Implements compression and efficient serialization for complex assessment state\r\n */ class OptimizedStorageService {\n    /**\r\n   * Compress SAIS distribution responses for efficient storage\r\n   */ compressSAISResponses(responses) {\n        const saisResponses = responses.filter((r)=>r.responseType === \"distribution\" && r.distributionA !== undefined && r.distributionB !== undefined);\n        const compressed = saisResponses.map((r)=>({\n                q: parseInt(r.questionId),\n                a: r.distributionA,\n                b: r.distributionB,\n                d: this.compressDimension(r.mbtiDimension),\n                t: Math.floor(new Date(r.timestamp || Date.now()).getTime() / 1000)\n            }));\n        const optimizedData = {\n            format: \"sais\",\n            responses: compressed,\n            metadata: {\n                totalQuestions: 16,\n                completed: saisResponses.length,\n                lastModified: Date.now()\n            }\n        };\n        const original = JSON.stringify(saisResponses);\n        const optimized = JSON.stringify(optimizedData);\n        return {\n            compressed: optimized,\n            originalSize: original.length,\n            compressedSize: optimized.length,\n            compressionRatio: (1 - optimized.length / original.length) * 100\n        };\n    }\n    /**\r\n   * Decompress SAIS responses back to original format\r\n   */ decompressSAISResponses(compressed) {\n        try {\n            const data = JSON.parse(compressed);\n            return data.responses.map((c)=>({\n                    questionId: c.q.toString(),\n                    responseId: \"sais-\".concat(c.q, \"-\").concat(Date.now()),\n                    sessionId: \"\",\n                    questionType: \"extended\",\n                    responseType: \"distribution\",\n                    distributionA: c.a,\n                    distributionB: c.b,\n                    mbtiDimension: this.decompressDimension(c.d),\n                    timestamp: new Date(c.t * 1000),\n                    score: 0\n                }));\n        } catch (error) {\n            console.error(\"Failed to decompress SAIS responses:\", error);\n            return [];\n        }\n    }\n    /**\r\n   * Optimized storage strategy for SAIS data\r\n   */ storeSAISAssessment(sessionId, data) {\n        try {\n            // Separate SAIS responses from other data\n            const { extendedResponses = [], ...otherData } = data;\n            // Compress SAIS responses if they exist\n            if (extendedResponses.length > 0 && data.selectedFormat === \"sais\") {\n                const compression = this.compressSAISResponses(extendedResponses);\n                // Store compressed SAIS data separately for better performance\n                const compressedKey = \"\".concat(this.COMPRESSION_PREFIX).concat(sessionId);\n                localStorage.setItem(compressedKey, compression.compressed);\n                // Store other data without extended responses\n                const mainData = {\n                    ...otherData,\n                    extendedResponsesCompressed: true,\n                    compressionStats: {\n                        originalSize: compression.originalSize,\n                        compressedSize: compression.compressedSize,\n                        ratio: compression.compressionRatio\n                    }\n                };\n                localStorage.setItem(sessionId, JSON.stringify(mainData));\n                // Log compression efficiency\n                if (compression.compressionRatio > 0) {\n                    console.log(\"SAIS compression saved \".concat(compression.compressionRatio.toFixed(1), \"% space\"));\n                }\n                return true;\n            } else {\n                // Non-SAIS or no extended responses, store normally\n                localStorage.setItem(sessionId, JSON.stringify(data));\n                return true;\n            }\n        } catch (error) {\n            console.error(\"Failed to store SAIS assessment:\", error);\n            return false;\n        }\n    }\n    /**\r\n   * Retrieve SAIS assessment with decompression\r\n   */ retrieveSAISAssessment(sessionId) {\n        try {\n            const mainDataStr = localStorage.getItem(sessionId);\n            if (!mainDataStr) return null;\n            const mainData = JSON.parse(mainDataStr);\n            // Check if SAIS responses are compressed\n            if (mainData.extendedResponsesCompressed) {\n                const compressedKey = \"\".concat(this.COMPRESSION_PREFIX).concat(sessionId);\n                const compressedData = localStorage.getItem(compressedKey);\n                if (compressedData) {\n                    const decompressed = this.decompressSAISResponses(compressedData);\n                    // Restore session ID\n                    const extendedResponses = decompressed.map((r)=>({\n                            ...r,\n                            sessionId\n                        }));\n                    return {\n                        ...mainData,\n                        extendedResponses,\n                        extendedResponsesCompressed: undefined,\n                        compressionStats: undefined\n                    };\n                }\n            }\n            return mainData;\n        } catch (error) {\n            console.error(\"Failed to retrieve SAIS assessment:\", error);\n            return null;\n        }\n    }\n    batchUpdateSAIS(sessionId, data) {\n        // Store pending update\n        this.pendingUpdates.set(sessionId, data);\n        // Clear existing timer\n        if (this.batchTimer) {\n            clearTimeout(this.batchTimer);\n        }\n        // Set new timer for batch processing\n        this.batchTimer = setTimeout(()=>{\n            this.processBatchUpdates();\n        }, 500); // 500ms debounce for rapid changes\n    }\n    processBatchUpdates() {\n        this.pendingUpdates.forEach((data, sessionId)=>{\n            this.storeSAISAssessment(sessionId, data);\n        });\n        this.pendingUpdates.clear();\n        this.batchTimer = null;\n    }\n    /**\r\n   * Clean up compressed data when session is cleared\r\n   */ cleanupSAISData(sessionId) {\n        try {\n            // Remove compressed data\n            const compressedKey = \"\".concat(this.COMPRESSION_PREFIX).concat(sessionId);\n            localStorage.removeItem(compressedKey);\n            // Remove main data\n            localStorage.removeItem(sessionId);\n            // Remove from pending updates if exists\n            this.pendingUpdates.delete(sessionId);\n        } catch (error) {\n            console.error(\"Failed to cleanup SAIS data:\", error);\n        }\n    }\n    /**\r\n   * Storage health check with SAIS-specific metrics\r\n   */ checkSAISStorageHealth() {\n        try {\n            let usedSpace = 0;\n            let compressedSessions = 0;\n            // Calculate used space and count compressed sessions\n            for(let i = 0; i < localStorage.length; i++){\n                const key = localStorage.key(i);\n                if (key) {\n                    const value = localStorage.getItem(key);\n                    if (value) {\n                        usedSpace += key.length + value.length;\n                        if (key.startsWith(this.COMPRESSION_PREFIX)) {\n                            compressedSessions++;\n                        }\n                    }\n                }\n            }\n            // Estimate available capacity (5MB typical limit)\n            const estimatedCapacity = 5 * 1024 * 1024 - usedSpace;\n            return {\n                available: true,\n                usedSpace,\n                estimatedCapacity,\n                compressedSessions\n            };\n        } catch (error) {\n            return {\n                available: false,\n                usedSpace: 0,\n                estimatedCapacity: 0,\n                compressedSessions: 0\n            };\n        }\n    }\n    /**\r\n   * Helper methods for dimension compression\r\n   */ compressDimension(dimension) {\n        // Extract first character of dimension (E-I becomes E, etc.)\n        return dimension.charAt(0);\n    }\n    decompressDimension(compressed) {\n        const mapping = {\n            \"E\": \"E/I\",\n            \"S\": \"S/N\",\n            \"T\": \"T/F\",\n            \"J\": \"J/P\"\n        };\n        return mapping[compressed] || \"E/I\";\n    }\n    /**\r\n   * Export/Import functionality for backup\r\n   */ exportSAISData(sessionId) {\n        const data = this.retrieveSAISAssessment(sessionId);\n        if (!data) return null;\n        // Create exportable format with compression\n        const exportData = {\n            version: \"1.0\",\n            format: \"sais-optimized\",\n            sessionId,\n            timestamp: new Date().toISOString(),\n            data: btoa(JSON.stringify(data)) // Base64 encode for safe transport\n        };\n        return JSON.stringify(exportData);\n    }\n    importSAISData(exportedData) {\n        try {\n            const parsed = JSON.parse(exportedData);\n            if (parsed.format !== \"sais-optimized\") return false;\n            const data = JSON.parse(atob(parsed.data));\n            return this.storeSAISAssessment(parsed.sessionId, data);\n        } catch (error) {\n            console.error(\"Failed to import SAIS data:\", error);\n            return false;\n        }\n    }\n    constructor(){\n        this.COMPRESSION_PREFIX = \"sais_compressed_\";\n        this.MAX_BATCH_SIZE = 5 // Batch saves for rapid changes\n        ;\n        /**\r\n   * Batch storage optimization for rapid SAIS point allocation changes\r\n   */ this.pendingUpdates = new Map();\n        this.batchTimer = null;\n    }\n}\n// Export singleton instance\nconst optimizedStorage = new OptimizedStorageService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvT3B0aW1pemVkU3RvcmFnZVNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0E2Qk0sTUFBTUE7SUFJWDs7R0FFQyxHQUNEQyxzQkFBc0JDLFNBQTZCLEVBQXFCO1FBQ3RFLE1BQU1DLGdCQUFnQkQsVUFBVUUsTUFBTSxDQUFDQyxDQUFBQSxJQUNyQ0EsRUFBRUMsWUFBWSxLQUFLLGtCQUNuQkQsRUFBRUUsYUFBYSxLQUFLQyxhQUNwQkgsRUFBRUksYUFBYSxLQUFLRDtRQUd0QixNQUFNRSxhQUF1Q1AsY0FBY1EsR0FBRyxDQUFDTixDQUFBQSxJQUFNO2dCQUNuRU8sR0FBR0MsU0FBU1IsRUFBRVMsVUFBVTtnQkFDeEJDLEdBQUdWLEVBQUVFLGFBQWE7Z0JBQ2xCUyxHQUFHWCxFQUFFSSxhQUFhO2dCQUNsQlEsR0FBRyxJQUFJLENBQUNDLGlCQUFpQixDQUFDYixFQUFFYyxhQUFhO2dCQUN6Q0MsR0FBR0MsS0FBS0MsS0FBSyxDQUFDLElBQUlDLEtBQUtsQixFQUFFbUIsU0FBUyxJQUFJRCxLQUFLRSxHQUFHLElBQUlDLE9BQU8sS0FBSztZQUNoRTtRQUVBLE1BQU1DLGdCQUFtQztZQUN2Q0MsUUFBUTtZQUNSMUIsV0FBV1E7WUFDWG1CLFVBQVU7Z0JBQ1JDLGdCQUFnQjtnQkFDaEJDLFdBQVc1QixjQUFjNkIsTUFBTTtnQkFDL0JDLGNBQWNWLEtBQUtFLEdBQUc7WUFDeEI7UUFDRjtRQUVBLE1BQU1TLFdBQVdDLEtBQUtDLFNBQVMsQ0FBQ2pDO1FBQ2hDLE1BQU1rQyxZQUFZRixLQUFLQyxTQUFTLENBQUNUO1FBRWpDLE9BQU87WUFDTGpCLFlBQVkyQjtZQUNaQyxjQUFjSixTQUFTRixNQUFNO1lBQzdCTyxnQkFBZ0JGLFVBQVVMLE1BQU07WUFDaENRLGtCQUFrQixDQUFDLElBQUlILFVBQVVMLE1BQU0sR0FBR0UsU0FBU0YsTUFBTSxJQUFJO1FBQy9EO0lBQ0Y7SUFF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ZUFBZWxELFNBQWlCLEVBQWlCO1FBQy9DLE1BQU1MLE9BQU8sSUFBSSxDQUFDMEIsc0JBQXNCLENBQUNyQjtRQUN6QyxJQUFJLENBQUNMLE1BQU0sT0FBTztRQUVsQiw0Q0FBNEM7UUFDNUMsTUFBTXdELGFBQWE7WUFDakJDLFNBQVM7WUFDVHZFLFFBQVE7WUFDUm1CO1lBQ0F2QixXQUFXLElBQUlELE9BQU82RSxXQUFXO1lBQ2pDMUQsTUFBTTJELEtBQUtsRSxLQUFLQyxTQUFTLENBQUNNLE9BQU8sbUNBQW1DO1FBQ3RFO1FBRUEsT0FBT1AsS0FBS0MsU0FBUyxDQUFDOEQ7SUFDeEI7SUFFQUksZUFBZUMsWUFBb0IsRUFBVztRQUM1QyxJQUFJO1lBQ0YsTUFBTUMsU0FBU3JFLEtBQUtRLEtBQUssQ0FBQzREO1lBQzFCLElBQUlDLE9BQU81RSxNQUFNLEtBQUssa0JBQWtCLE9BQU87WUFFL0MsTUFBTWMsT0FBT1AsS0FBS1EsS0FBSyxDQUFDOEQsS0FBS0QsT0FBTzlELElBQUk7WUFDeEMsT0FBTyxJQUFJLENBQUNXLG1CQUFtQixDQUFDbUQsT0FBT3pELFNBQVMsRUFBRUw7UUFDcEQsRUFBRSxPQUFPUyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDLE9BQU87UUFDVDtJQUNGOzthQXpTaUJRLHFCQUFxQjthQUNyQitDLGlCQUFpQixFQUFHLGdDQUFnQzs7UUF3SnJFOztHQUVDLFFBQ09oQyxpQkFBaUIsSUFBSWlDO2FBQ3JCL0IsYUFBb0M7O0FBNkk5QztBQUVBLDRCQUE0QjtBQUNyQixNQUFNZ0MsbUJBQW1CLElBQUk1RywwQkFBMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zZXJ2aWNlcy9PcHRpbWl6ZWRTdG9yYWdlU2VydmljZS50cz85ZTAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBPcHRpbWl6ZWQgU3RvcmFnZSBTZXJ2aWNlIGZvciBTQUlTIERpc3RyaWJ1dGlvbiBEYXRhXHJcbiAqIEltcGxlbWVudHMgY29tcHJlc3Npb24gYW5kIGVmZmljaWVudCBzZXJpYWxpemF0aW9uIGZvciBjb21wbGV4IGFzc2Vzc21lbnQgc3RhdGVcclxuICovXHJcblxyXG5pbXBvcnQgeyBRdWVzdGlvblJlc3BvbnNlIH0gZnJvbSAnQC9saWIvdHlwZXMnO1xyXG5cclxuaW50ZXJmYWNlIENvbXByZXNzaW9uUmVzdWx0IHtcclxuICBjb21wcmVzc2VkOiBzdHJpbmc7XHJcbiAgb3JpZ2luYWxTaXplOiBudW1iZXI7XHJcbiAgY29tcHJlc3NlZFNpemU6IG51bWJlcjtcclxuICBjb21wcmVzc2lvblJhdGlvOiBudW1iZXI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBTQUlTT3B0aW1pemVkRGF0YSB7XHJcbiAgZm9ybWF0OiAnc2Fpcyc7XHJcbiAgcmVzcG9uc2VzOiBDb21wcmVzc2VkU0FJU1Jlc3BvbnNlW107XHJcbiAgbWV0YWRhdGE6IHtcclxuICAgIHRvdGFsUXVlc3Rpb25zOiBudW1iZXI7XHJcbiAgICBjb21wbGV0ZWQ6IG51bWJlcjtcclxuICAgIGxhc3RNb2RpZmllZDogbnVtYmVyO1xyXG4gIH07XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb21wcmVzc2VkU0FJU1Jlc3BvbnNlIHtcclxuICBxOiBudW1iZXI7IC8vIHF1ZXN0aW9uSWQgKG51bWJlciBmb3IgY29tcHJlc3Npb24pXHJcbiAgYTogbnVtYmVyOyAvLyBkaXN0cmlidXRpb25BICgwLTUpXHJcbiAgYjogbnVtYmVyOyAvLyBkaXN0cmlidXRpb25CICgwLTUpXHJcbiAgZDogc3RyaW5nOyAvLyBtYnRpRGltZW5zaW9uIChzaW5nbGUgY2hhcjogRSwgUywgVCwgSilcclxuICB0OiBudW1iZXI7IC8vIHRpbWVzdGFtcCAoZXBvY2ggc2Vjb25kcylcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE9wdGltaXplZFN0b3JhZ2VTZXJ2aWNlIHtcclxuICBwcml2YXRlIHJlYWRvbmx5IENPTVBSRVNTSU9OX1BSRUZJWCA9ICdzYWlzX2NvbXByZXNzZWRfJztcclxuICBwcml2YXRlIHJlYWRvbmx5IE1BWF9CQVRDSF9TSVpFID0gNTsgLy8gQmF0Y2ggc2F2ZXMgZm9yIHJhcGlkIGNoYW5nZXNcclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHJlc3MgU0FJUyBkaXN0cmlidXRpb24gcmVzcG9uc2VzIGZvciBlZmZpY2llbnQgc3RvcmFnZVxyXG4gICAqL1xyXG4gIGNvbXByZXNzU0FJU1Jlc3BvbnNlcyhyZXNwb25zZXM6IFF1ZXN0aW9uUmVzcG9uc2VbXSk6IENvbXByZXNzaW9uUmVzdWx0IHtcclxuICAgIGNvbnN0IHNhaXNSZXNwb25zZXMgPSByZXNwb25zZXMuZmlsdGVyKHIgPT4gXHJcbiAgICAgIHIucmVzcG9uc2VUeXBlID09PSAnZGlzdHJpYnV0aW9uJyAmJiBcclxuICAgICAgci5kaXN0cmlidXRpb25BICE9PSB1bmRlZmluZWQgJiYgXHJcbiAgICAgIHIuZGlzdHJpYnV0aW9uQiAhPT0gdW5kZWZpbmVkXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGNvbXByZXNzZWQ6IENvbXByZXNzZWRTQUlTUmVzcG9uc2VbXSA9IHNhaXNSZXNwb25zZXMubWFwKHIgPT4gKHtcclxuICAgICAgcTogcGFyc2VJbnQoci5xdWVzdGlvbklkKSxcclxuICAgICAgYTogci5kaXN0cmlidXRpb25BISxcclxuICAgICAgYjogci5kaXN0cmlidXRpb25CISxcclxuICAgICAgZDogdGhpcy5jb21wcmVzc0RpbWVuc2lvbihyLm1idGlEaW1lbnNpb24pLFxyXG4gICAgICB0OiBNYXRoLmZsb29yKG5ldyBEYXRlKHIudGltZXN0YW1wIHx8IERhdGUubm93KCkpLmdldFRpbWUoKSAvIDEwMDApXHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3Qgb3B0aW1pemVkRGF0YTogU0FJU09wdGltaXplZERhdGEgPSB7XHJcbiAgICAgIGZvcm1hdDogJ3NhaXMnLFxyXG4gICAgICByZXNwb25zZXM6IGNvbXByZXNzZWQsXHJcbiAgICAgIG1ldGFkYXRhOiB7XHJcbiAgICAgICAgdG90YWxRdWVzdGlvbnM6IDE2LFxyXG4gICAgICAgIGNvbXBsZXRlZDogc2Fpc1Jlc3BvbnNlcy5sZW5ndGgsXHJcbiAgICAgICAgbGFzdE1vZGlmaWVkOiBEYXRlLm5vdygpXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb3JpZ2luYWwgPSBKU09OLnN0cmluZ2lmeShzYWlzUmVzcG9uc2VzKTtcclxuICAgIGNvbnN0IG9wdGltaXplZCA9IEpTT04uc3RyaW5naWZ5KG9wdGltaXplZERhdGEpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvbXByZXNzZWQ6IG9wdGltaXplZCxcclxuICAgICAgb3JpZ2luYWxTaXplOiBvcmlnaW5hbC5sZW5ndGgsXHJcbiAgICAgIGNvbXByZXNzZWRTaXplOiBvcHRpbWl6ZWQubGVuZ3RoLFxyXG4gICAgICBjb21wcmVzc2lvblJhdGlvOiAoMSAtIG9wdGltaXplZC5sZW5ndGggLyBvcmlnaW5hbC5sZW5ndGgpICogMTAwXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVjb21wcmVzcyBTQUlTIHJlc3BvbnNlcyBiYWNrIHRvIG9yaWdpbmFsIGZvcm1hdFxyXG4gICAqL1xyXG4gIGRlY29tcHJlc3NTQUlTUmVzcG9uc2VzKGNvbXByZXNzZWQ6IHN0cmluZyk6IFF1ZXN0aW9uUmVzcG9uc2VbXSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhOiBTQUlTT3B0aW1pemVkRGF0YSA9IEpTT04ucGFyc2UoY29tcHJlc3NlZCk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gZGF0YS5yZXNwb25zZXMubWFwKGMgPT4gKHtcclxuICAgICAgICBxdWVzdGlvbklkOiBjLnEudG9TdHJpbmcoKSxcclxuICAgICAgICByZXNwb25zZUlkOiBgc2Fpcy0ke2MucX0tJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgc2Vzc2lvbklkOiAnJywgLy8gV2lsbCBiZSBmaWxsZWQgYnkgY2FsbGVyXHJcbiAgICAgICAgcXVlc3Rpb25UeXBlOiAnZXh0ZW5kZWQnIGFzIGNvbnN0LFxyXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2Rpc3RyaWJ1dGlvbicgYXMgY29uc3QsXHJcbiAgICAgICAgZGlzdHJpYnV0aW9uQTogYy5hLFxyXG4gICAgICAgIGRpc3RyaWJ1dGlvbkI6IGMuYixcclxuICAgICAgICBtYnRpRGltZW5zaW9uOiB0aGlzLmRlY29tcHJlc3NEaW1lbnNpb24oYy5kKSxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKGMudCAqIDEwMDApLFxyXG4gICAgICAgIHNjb3JlOiAwLCAvLyBDYWxjdWxhdGVkIGxhdGVyXHJcbiAgICAgIH0pKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWNvbXByZXNzIFNBSVMgcmVzcG9uc2VzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3B0aW1pemVkIHN0b3JhZ2Ugc3RyYXRlZ3kgZm9yIFNBSVMgZGF0YVxyXG4gICAqL1xyXG4gIHN0b3JlU0FJU0Fzc2Vzc21lbnQoc2Vzc2lvbklkOiBzdHJpbmcsIGRhdGE6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU2VwYXJhdGUgU0FJUyByZXNwb25zZXMgZnJvbSBvdGhlciBkYXRhXHJcbiAgICAgIGNvbnN0IHsgZXh0ZW5kZWRSZXNwb25zZXMgPSBbXSwgLi4ub3RoZXJEYXRhIH0gPSBkYXRhO1xyXG4gICAgICBcclxuICAgICAgLy8gQ29tcHJlc3MgU0FJUyByZXNwb25zZXMgaWYgdGhleSBleGlzdFxyXG4gICAgICBpZiAoZXh0ZW5kZWRSZXNwb25zZXMubGVuZ3RoID4gMCAmJiBkYXRhLnNlbGVjdGVkRm9ybWF0ID09PSAnc2FpcycpIHtcclxuICAgICAgICBjb25zdCBjb21wcmVzc2lvbiA9IHRoaXMuY29tcHJlc3NTQUlTUmVzcG9uc2VzKGV4dGVuZGVkUmVzcG9uc2VzKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTdG9yZSBjb21wcmVzc2VkIFNBSVMgZGF0YSBzZXBhcmF0ZWx5IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcclxuICAgICAgICBjb25zdCBjb21wcmVzc2VkS2V5ID0gYCR7dGhpcy5DT01QUkVTU0lPTl9QUkVGSVh9JHtzZXNzaW9uSWR9YDtcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShjb21wcmVzc2VkS2V5LCBjb21wcmVzc2lvbi5jb21wcmVzc2VkKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTdG9yZSBvdGhlciBkYXRhIHdpdGhvdXQgZXh0ZW5kZWQgcmVzcG9uc2VzXHJcbiAgICAgICAgY29uc3QgbWFpbkRhdGEgPSB7XHJcbiAgICAgICAgICAuLi5vdGhlckRhdGEsXHJcbiAgICAgICAgICBleHRlbmRlZFJlc3BvbnNlc0NvbXByZXNzZWQ6IHRydWUsXHJcbiAgICAgICAgICBjb21wcmVzc2lvblN0YXRzOiB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU2l6ZTogY29tcHJlc3Npb24ub3JpZ2luYWxTaXplLFxyXG4gICAgICAgICAgICBjb21wcmVzc2VkU2l6ZTogY29tcHJlc3Npb24uY29tcHJlc3NlZFNpemUsXHJcbiAgICAgICAgICAgIHJhdGlvOiBjb21wcmVzc2lvbi5jb21wcmVzc2lvblJhdGlvXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzZXNzaW9uSWQsIEpTT04uc3RyaW5naWZ5KG1haW5EYXRhKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9nIGNvbXByZXNzaW9uIGVmZmljaWVuY3lcclxuICAgICAgICBpZiAoY29tcHJlc3Npb24uY29tcHJlc3Npb25SYXRpbyA+IDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBTQUlTIGNvbXByZXNzaW9uIHNhdmVkICR7Y29tcHJlc3Npb24uY29tcHJlc3Npb25SYXRpby50b0ZpeGVkKDEpfSUgc3BhY2VgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTm9uLVNBSVMgb3Igbm8gZXh0ZW5kZWQgcmVzcG9uc2VzLCBzdG9yZSBub3JtYWxseVxyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHNlc3Npb25JZCwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc3RvcmUgU0FJUyBhc3Nlc3NtZW50OicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmUgU0FJUyBhc3Nlc3NtZW50IHdpdGggZGVjb21wcmVzc2lvblxyXG4gICAqL1xyXG4gIHJldHJpZXZlU0FJU0Fzc2Vzc21lbnQoc2Vzc2lvbklkOiBzdHJpbmcpOiBhbnkgfCBudWxsIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IG1haW5EYXRhU3RyID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oc2Vzc2lvbklkKTtcclxuICAgICAgaWYgKCFtYWluRGF0YVN0cikgcmV0dXJuIG51bGw7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBtYWluRGF0YSA9IEpTT04ucGFyc2UobWFpbkRhdGFTdHIpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgU0FJUyByZXNwb25zZXMgYXJlIGNvbXByZXNzZWRcclxuICAgICAgaWYgKG1haW5EYXRhLmV4dGVuZGVkUmVzcG9uc2VzQ29tcHJlc3NlZCkge1xyXG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWRLZXkgPSBgJHt0aGlzLkNPTVBSRVNTSU9OX1BSRUZJWH0ke3Nlc3Npb25JZH1gO1xyXG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWREYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oY29tcHJlc3NlZEtleSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNvbXByZXNzZWREYXRhKSB7XHJcbiAgICAgICAgICBjb25zdCBkZWNvbXByZXNzZWQgPSB0aGlzLmRlY29tcHJlc3NTQUlTUmVzcG9uc2VzKGNvbXByZXNzZWREYXRhKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gUmVzdG9yZSBzZXNzaW9uIElEXHJcbiAgICAgICAgICBjb25zdCBleHRlbmRlZFJlc3BvbnNlcyA9IGRlY29tcHJlc3NlZC5tYXAociA9PiAoe1xyXG4gICAgICAgICAgICAuLi5yLFxyXG4gICAgICAgICAgICBzZXNzaW9uSWRcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4ubWFpbkRhdGEsXHJcbiAgICAgICAgICAgIGV4dGVuZGVkUmVzcG9uc2VzLFxyXG4gICAgICAgICAgICBleHRlbmRlZFJlc3BvbnNlc0NvbXByZXNzZWQ6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgY29tcHJlc3Npb25TdGF0czogdW5kZWZpbmVkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIG1haW5EYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJldHJpZXZlIFNBSVMgYXNzZXNzbWVudDonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmF0Y2ggc3RvcmFnZSBvcHRpbWl6YXRpb24gZm9yIHJhcGlkIFNBSVMgcG9pbnQgYWxsb2NhdGlvbiBjaGFuZ2VzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBwZW5kaW5nVXBkYXRlcyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XHJcbiAgcHJpdmF0ZSBiYXRjaFRpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xyXG5cclxuICBiYXRjaFVwZGF0ZVNBSVMoc2Vzc2lvbklkOiBzdHJpbmcsIGRhdGE6IGFueSk6IHZvaWQge1xyXG4gICAgLy8gU3RvcmUgcGVuZGluZyB1cGRhdGVcclxuICAgIHRoaXMucGVuZGluZ1VwZGF0ZXMuc2V0KHNlc3Npb25JZCwgZGF0YSk7XHJcbiAgICBcclxuICAgIC8vIENsZWFyIGV4aXN0aW5nIHRpbWVyXHJcbiAgICBpZiAodGhpcy5iYXRjaFRpbWVyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmJhdGNoVGltZXIpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTZXQgbmV3IHRpbWVyIGZvciBiYXRjaCBwcm9jZXNzaW5nXHJcbiAgICB0aGlzLmJhdGNoVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpcy5wcm9jZXNzQmF0Y2hVcGRhdGVzKCk7XHJcbiAgICB9LCA1MDApOyAvLyA1MDBtcyBkZWJvdW5jZSBmb3IgcmFwaWQgY2hhbmdlc1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBwcm9jZXNzQmF0Y2hVcGRhdGVzKCk6IHZvaWQge1xyXG4gICAgdGhpcy5wZW5kaW5nVXBkYXRlcy5mb3JFYWNoKChkYXRhLCBzZXNzaW9uSWQpID0+IHtcclxuICAgICAgdGhpcy5zdG9yZVNBSVNBc3Nlc3NtZW50KHNlc3Npb25JZCwgZGF0YSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgdGhpcy5wZW5kaW5nVXBkYXRlcy5jbGVhcigpO1xyXG4gICAgdGhpcy5iYXRjaFRpbWVyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFuIHVwIGNvbXByZXNzZWQgZGF0YSB3aGVuIHNlc3Npb24gaXMgY2xlYXJlZFxyXG4gICAqL1xyXG4gIGNsZWFudXBTQUlTRGF0YShzZXNzaW9uSWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gUmVtb3ZlIGNvbXByZXNzZWQgZGF0YVxyXG4gICAgICBjb25zdCBjb21wcmVzc2VkS2V5ID0gYCR7dGhpcy5DT01QUkVTU0lPTl9QUkVGSVh9JHtzZXNzaW9uSWR9YDtcclxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oY29tcHJlc3NlZEtleSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZW1vdmUgbWFpbiBkYXRhXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHNlc3Npb25JZCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZW1vdmUgZnJvbSBwZW5kaW5nIHVwZGF0ZXMgaWYgZXhpc3RzXHJcbiAgICAgIHRoaXMucGVuZGluZ1VwZGF0ZXMuZGVsZXRlKHNlc3Npb25JZCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2xlYW51cCBTQUlTIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcmFnZSBoZWFsdGggY2hlY2sgd2l0aCBTQUlTLXNwZWNpZmljIG1ldHJpY3NcclxuICAgKi9cclxuICBjaGVja1NBSVNTdG9yYWdlSGVhbHRoKCk6IHtcclxuICAgIGF2YWlsYWJsZTogYm9vbGVhbjtcclxuICAgIHVzZWRTcGFjZTogbnVtYmVyO1xyXG4gICAgZXN0aW1hdGVkQ2FwYWNpdHk6IG51bWJlcjtcclxuICAgIGNvbXByZXNzZWRTZXNzaW9uczogbnVtYmVyO1xyXG4gIH0ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbGV0IHVzZWRTcGFjZSA9IDA7XHJcbiAgICAgIGxldCBjb21wcmVzc2VkU2Vzc2lvbnMgPSAwO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2FsY3VsYXRlIHVzZWQgc3BhY2UgYW5kIGNvdW50IGNvbXByZXNzZWQgc2Vzc2lvbnNcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcclxuICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB1c2VkU3BhY2UgKz0ga2V5Lmxlbmd0aCArIHZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCh0aGlzLkNPTVBSRVNTSU9OX1BSRUZJWCkpIHtcclxuICAgICAgICAgICAgICBjb21wcmVzc2VkU2Vzc2lvbnMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gRXN0aW1hdGUgYXZhaWxhYmxlIGNhcGFjaXR5ICg1TUIgdHlwaWNhbCBsaW1pdClcclxuICAgICAgY29uc3QgZXN0aW1hdGVkQ2FwYWNpdHkgPSA1ICogMTAyNCAqIDEwMjQgLSB1c2VkU3BhY2U7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGF2YWlsYWJsZTogdHJ1ZSxcclxuICAgICAgICB1c2VkU3BhY2UsXHJcbiAgICAgICAgZXN0aW1hdGVkQ2FwYWNpdHksXHJcbiAgICAgICAgY29tcHJlc3NlZFNlc3Npb25zXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGF2YWlsYWJsZTogZmFsc2UsXHJcbiAgICAgICAgdXNlZFNwYWNlOiAwLFxyXG4gICAgICAgIGVzdGltYXRlZENhcGFjaXR5OiAwLFxyXG4gICAgICAgIGNvbXByZXNzZWRTZXNzaW9uczogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGVscGVyIG1ldGhvZHMgZm9yIGRpbWVuc2lvbiBjb21wcmVzc2lvblxyXG4gICAqL1xyXG4gIHByaXZhdGUgY29tcHJlc3NEaW1lbnNpb24oZGltZW5zaW9uOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgLy8gRXh0cmFjdCBmaXJzdCBjaGFyYWN0ZXIgb2YgZGltZW5zaW9uIChFLUkgYmVjb21lcyBFLCBldGMuKVxyXG4gICAgcmV0dXJuIGRpbWVuc2lvbi5jaGFyQXQoMCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRlY29tcHJlc3NEaW1lbnNpb24oY29tcHJlc3NlZDogc3RyaW5nKTogJ0UvSScgfCAnUy9OJyB8ICdUL0YnIHwgJ0ovUCcge1xyXG4gICAgY29uc3QgbWFwcGluZzogUmVjb3JkPHN0cmluZywgJ0UvSScgfCAnUy9OJyB8ICdUL0YnIHwgJ0ovUCc+ID0ge1xyXG4gICAgICAnRSc6ICdFL0knLFxyXG4gICAgICAnUyc6ICdTL04nLFxyXG4gICAgICAnVCc6ICdUL0YnLFxyXG4gICAgICAnSic6ICdKL1AnXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG1hcHBpbmdbY29tcHJlc3NlZF0gfHwgJ0UvSSc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHBvcnQvSW1wb3J0IGZ1bmN0aW9uYWxpdHkgZm9yIGJhY2t1cFxyXG4gICAqL1xyXG4gIGV4cG9ydFNBSVNEYXRhKHNlc3Npb25JZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXRyaWV2ZVNBSVNBc3Nlc3NtZW50KHNlc3Npb25JZCk7XHJcbiAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgZXhwb3J0YWJsZSBmb3JtYXQgd2l0aCBjb21wcmVzc2lvblxyXG4gICAgY29uc3QgZXhwb3J0RGF0YSA9IHtcclxuICAgICAgdmVyc2lvbjogJzEuMCcsXHJcbiAgICAgIGZvcm1hdDogJ3NhaXMtb3B0aW1pemVkJyxcclxuICAgICAgc2Vzc2lvbklkLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgZGF0YTogYnRvYShKU09OLnN0cmluZ2lmeShkYXRhKSkgLy8gQmFzZTY0IGVuY29kZSBmb3Igc2FmZSB0cmFuc3BvcnRcclxuICAgIH07XHJcbiAgICBcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShleHBvcnREYXRhKTtcclxuICB9XHJcblxyXG4gIGltcG9ydFNBSVNEYXRhKGV4cG9ydGVkRGF0YTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGV4cG9ydGVkRGF0YSk7XHJcbiAgICAgIGlmIChwYXJzZWQuZm9ybWF0ICE9PSAnc2Fpcy1vcHRpbWl6ZWQnKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShhdG9iKHBhcnNlZC5kYXRhKSk7XHJcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlU0FJU0Fzc2Vzc21lbnQocGFyc2VkLnNlc3Npb25JZCwgZGF0YSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW1wb3J0IFNBSVMgZGF0YTonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IG9wdGltaXplZFN0b3JhZ2UgPSBuZXcgT3B0aW1pemVkU3RvcmFnZVNlcnZpY2UoKTsiXSwibmFtZXMiOlsiT3B0aW1pemVkU3RvcmFnZVNlcnZpY2UiLCJjb21wcmVzc1NBSVNSZXNwb25zZXMiLCJyZXNwb25zZXMiLCJzYWlzUmVzcG9uc2VzIiwiZmlsdGVyIiwiciIsInJlc3BvbnNlVHlwZSIsImRpc3RyaWJ1dGlvbkEiLCJ1bmRlZmluZWQiLCJkaXN0cmlidXRpb25CIiwiY29tcHJlc3NlZCIsIm1hcCIsInEiLCJwYXJzZUludCIsInF1ZXN0aW9uSWQiLCJhIiwiYiIsImQiLCJjb21wcmVzc0RpbWVuc2lvbiIsIm1idGlEaW1lbnNpb24iLCJ0IiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsInRpbWVzdGFtcCIsIm5vdyIsImdldFRpbWUiLCJvcHRpbWl6ZWREYXRhIiwiZm9ybWF0IiwibWV0YWRhdGEiLCJ0b3RhbFF1ZXN0aW9ucyIsImNvbXBsZXRlZCIsImxlbmd0aCIsImxhc3RNb2RpZmllZCIsIm9yaWdpbmFsIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9wdGltaXplZCIsIm9yaWdpbmFsU2l6ZSIsImNvbXByZXNzZWRTaXplIiwiY29tcHJlc3Npb25SYXRpbyIsImRlY29tcHJlc3NTQUlTUmVzcG9uc2VzIiwiZGF0YSIsInBhcnNlIiwiYyIsInRvU3RyaW5nIiwicmVzcG9uc2VJZCIsInNlc3Npb25JZCIsInF1ZXN0aW9uVHlwZSIsImRlY29tcHJlc3NEaW1lbnNpb24iLCJzY29yZSIsImVycm9yIiwiY29uc29sZSIsInN0b3JlU0FJU0Fzc2Vzc21lbnQiLCJleHRlbmRlZFJlc3BvbnNlcyIsIm90aGVyRGF0YSIsInNlbGVjdGVkRm9ybWF0IiwiY29tcHJlc3Npb24iLCJjb21wcmVzc2VkS2V5IiwiQ09NUFJFU1NJT05fUFJFRklYIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIm1haW5EYXRhIiwiZXh0ZW5kZWRSZXNwb25zZXNDb21wcmVzc2VkIiwiY29tcHJlc3Npb25TdGF0cyIsInJhdGlvIiwibG9nIiwidG9GaXhlZCIsInJldHJpZXZlU0FJU0Fzc2Vzc21lbnQiLCJtYWluRGF0YVN0ciIsImdldEl0ZW0iLCJjb21wcmVzc2VkRGF0YSIsImRlY29tcHJlc3NlZCIsImJhdGNoVXBkYXRlU0FJUyIsInBlbmRpbmdVcGRhdGVzIiwic2V0IiwiYmF0Y2hUaW1lciIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJwcm9jZXNzQmF0Y2hVcGRhdGVzIiwiZm9yRWFjaCIsImNsZWFyIiwiY2xlYW51cFNBSVNEYXRhIiwicmVtb3ZlSXRlbSIsImRlbGV0ZSIsImNoZWNrU0FJU1N0b3JhZ2VIZWFsdGgiLCJ1c2VkU3BhY2UiLCJjb21wcmVzc2VkU2Vzc2lvbnMiLCJpIiwia2V5IiwidmFsdWUiLCJzdGFydHNXaXRoIiwiZXN0aW1hdGVkQ2FwYWNpdHkiLCJhdmFpbGFibGUiLCJkaW1lbnNpb24iLCJjaGFyQXQiLCJtYXBwaW5nIiwiZXhwb3J0U0FJU0RhdGEiLCJleHBvcnREYXRhIiwidmVyc2lvbiIsInRvSVNPU3RyaW5nIiwiYnRvYSIsImltcG9ydFNBSVNEYXRhIiwiZXhwb3J0ZWREYXRhIiwicGFyc2VkIiwiYXRvYiIsIk1BWF9CQVRDSF9TSVpFIiwiTWFwIiwib3B0aW1pemVkU3RvcmFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/OptimizedStorageService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/services/SessionService.ts":
/*!********************************************!*\
  !*** ./src/lib/services/SessionService.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SessionService: function() { return /* binding */ SessionService; }\n/* harmony export */ });\n/**\r\n * SessionService - Client-side session management with phase-based expiration\r\n * Handles different session phases (core vs extended) with appropriate timeouts\r\n */ // Session timeout constants\nconst CORE_SESSION_TIMEOUT = 3 * 60 * 60 * 1000; // 3 hours\nconst EXTENDED_SESSION_TIMEOUT = 48 * 60 * 60 * 1000; // 48 hours\nconst SESSION_EXTENSION_INTERVAL = 5 * 60 * 1000; // 5 minutes\nclass SessionService {\n    /**\r\n   * Initialize a new session\r\n   */ static initializeSession(sessionId) {\n        let phase = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"core\";\n        const now = Date.now();\n        const timeout = this.getTimeoutForPhase(phase);\n        const sessionData = {\n            sessionId,\n            phase,\n            createdAt: now,\n            lastActiveAt: now,\n            expiresAt: now + timeout\n        };\n        this.saveSessionData(sessionData);\n        this.startAutoExtension();\n        return sessionData;\n    }\n    /**\r\n   * Get timeout duration for a specific phase\r\n   */ static getTimeoutForPhase(phase) {\n        return phase === \"extended\" ? EXTENDED_SESSION_TIMEOUT : CORE_SESSION_TIMEOUT;\n    }\n    /**\r\n   * Transition session to extended phase (after format selection)\r\n   */ static transitionToExtendedPhase(sessionId) {\n        const sessionData = this.getSessionData();\n        if (!sessionData || sessionData.sessionId !== sessionId) {\n            return null;\n        }\n        const now = Date.now();\n        sessionData.phase = \"extended\";\n        sessionData.extendedPhaseStartedAt = now;\n        sessionData.lastActiveAt = now;\n        sessionData.expiresAt = now + EXTENDED_SESSION_TIMEOUT;\n        this.saveSessionData(sessionData);\n        return sessionData;\n    }\n    /**\r\n   * Update session activity (extends expiration during active use)\r\n   */ static updateActivity() {\n        const sessionData = this.getSessionData();\n        if (!sessionData || this.isSessionExpired(sessionData)) {\n            return;\n        }\n        const now = Date.now();\n        sessionData.lastActiveAt = now;\n        // Only extend if actively being used (within last 5 minutes)\n        if (sessionData.phase === \"extended\") {\n            const timeSinceLastActivity = now - sessionData.lastActiveAt;\n            if (timeSinceLastActivity < SESSION_EXTENSION_INTERVAL) {\n                // Extend by another 48 hours from now\n                sessionData.expiresAt = now + EXTENDED_SESSION_TIMEOUT;\n            }\n        }\n        this.saveSessionData(sessionData);\n    }\n    /**\r\n   * Check if session is in extended phase\r\n   */ static isExtendedPhase() {\n        const sessionData = this.getSessionData();\n        return (sessionData === null || sessionData === void 0 ? void 0 : sessionData.phase) === \"extended\" || false;\n    }\n    /**\r\n   * Get current session phase\r\n   */ static getCurrentPhase() {\n        const sessionData = this.getSessionData();\n        return (sessionData === null || sessionData === void 0 ? void 0 : sessionData.phase) || null;\n    }\n    /**\r\n   * Check if session has expired\r\n   */ static isSessionExpired(sessionData) {\n        const data = sessionData || this.getSessionData();\n        if (!data) {\n            return true;\n        }\n        return Date.now() > data.expiresAt;\n    }\n    /**\r\n   * Get time remaining for current session\r\n   */ static getTimeRemaining() {\n        const sessionData = this.getSessionData();\n        if (!sessionData || this.isSessionExpired(sessionData)) {\n            return 0;\n        }\n        return Math.max(0, sessionData.expiresAt - Date.now());\n    }\n    /**\r\n   * Clean up expired session\r\n   */ static cleanupExpiredSession() {\n        const sessionData = this.getSessionData();\n        if (sessionData && this.isSessionExpired(sessionData)) {\n            this.clearSessionData();\n        }\n    }\n    /**\r\n   * Get session data from storage\r\n   */ static getSessionData() {\n        try {\n            const data = localStorage.getItem(this.SESSION_KEY);\n            if (!data) return null;\n            return JSON.parse(data);\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\r\n   * Save session data to storage\r\n   */ static saveSessionData(data) {\n        try {\n            localStorage.setItem(this.SESSION_KEY, JSON.stringify(data));\n        } catch (error) {\n            console.error(\"Failed to save session data:\", error);\n        }\n    }\n    /**\r\n   * Clear session data\r\n   */ static clearSessionData() {\n        try {\n            localStorage.removeItem(this.SESSION_KEY);\n            this.stopAutoExtension();\n        } catch (error) {\n            console.error(\"Failed to clear session data:\", error);\n        }\n    }\n    /**\r\n   * Start automatic session extension timer\r\n   */ static startAutoExtension() {\n        this.stopAutoExtension();\n        // Check every 5 minutes for activity-based extension\n        this.extensionTimer = setInterval(()=>{\n            this.updateActivity();\n        }, SESSION_EXTENSION_INTERVAL);\n    }\n    /**\r\n   * Stop automatic session extension timer\r\n   */ static stopAutoExtension() {\n        if (this.extensionTimer) {\n            clearInterval(this.extensionTimer);\n            this.extensionTimer = null;\n        }\n    }\n    /**\r\n   * Validate assessment state matches session\r\n   */ static validateSessionState(assessmentState) {\n        const sessionData = this.getSessionData();\n        if (!sessionData) {\n            return false;\n        }\n        // Check if session IDs match\n        if (assessmentState.sessionId !== sessionData.sessionId) {\n            return false;\n        }\n        // Check if session has expired\n        if (this.isSessionExpired(sessionData)) {\n            return false;\n        }\n        // Validate phase consistency\n        const hasSelectedFormat = assessmentState.selectedFormat !== null && (assessmentState.currentStep === \"questions\" || assessmentState.currentStep === \"results\" || assessmentState.currentStep === \"coaching\");\n        const shouldBeExtended = hasSelectedFormat && sessionData.phase === \"extended\";\n        const shouldBeCore = !hasSelectedFormat && sessionData.phase === \"core\";\n        return shouldBeExtended || shouldBeCore;\n    }\n    /**\r\n   * Get session summary for debugging/UI\r\n   */ static getSessionSummary() {\n        const sessionData = this.getSessionData();\n        const isExpired = this.isSessionExpired(sessionData);\n        if (!sessionData || isExpired) {\n            return {\n                isActive: false,\n                phase: null,\n                timeRemaining: \"0h 0m\",\n                expiresAt: null\n            };\n        }\n        const timeRemaining = this.getTimeRemaining();\n        const hours = Math.floor(timeRemaining / (60 * 60 * 1000));\n        const minutes = Math.floor(timeRemaining % (60 * 60 * 1000) / (60 * 1000));\n        return {\n            isActive: true,\n            phase: sessionData.phase,\n            timeRemaining: \"\".concat(hours, \"h \").concat(minutes, \"m\"),\n            expiresAt: new Date(sessionData.expiresAt)\n        };\n    }\n}\nSessionService.SESSION_KEY = \"mbti-session-data\";\nSessionService.extensionTimer = null;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvU2Vzc2lvblNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Q0FHQyxHQUlELDRCQUE0QjtBQUM1QixNQUFNQSx1QkFBdUIsSUFBSSxLQUFLLEtBQUssTUFBTSxVQUFVO0FBQzNELE1BQU1DLDJCQUEyQixLQUFLLEtBQUssS0FBSyxNQUFNLFdBQVc7QUFDakUsTUFBTUMsNkJBQTZCLElBQUksS0FBSyxNQUFNLFlBQVk7QUFjdkQsTUFBTUM7SUFJWDs7R0FFQyxHQUNELE9BQU9DLGtCQUFrQkMsU0FBaUIsRUFBNkM7WUFBM0NDLFFBQUFBLGlFQUFzQjtRQUNoRSxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO1FBQ3BCLE1BQU1FLFVBQVUsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ0o7UUFFeEMsTUFBTUssY0FBMkI7WUFDL0JOO1lBQ0FDO1lBQ0FNLFdBQVdMO1lBQ1hNLGNBQWNOO1lBQ2RPLFdBQVdQLE1BQU1FO1FBQ25CO1FBRUEsSUFBSSxDQUFDTSxlQUFlLENBQUNKO1FBQ3JCLElBQUksQ0FBQ0ssa0JBQWtCO1FBRXZCLE9BQU9MO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELE9BQU9ELG1CQUFtQkosS0FBbUIsRUFBVTtRQUNyRCxPQUFPQSxVQUFVLGFBQWFMLDJCQUEyQkQ7SUFDM0Q7SUFFQTs7R0FFQyxHQUNELE9BQU9pQiwwQkFBMEJaLFNBQWlCLEVBQXNCO1FBQ3RFLE1BQU1NLGNBQWMsSUFBSSxDQUFDTyxjQUFjO1FBRXZDLElBQUksQ0FBQ1AsZUFBZUEsWUFBWU4sU0FBUyxLQUFLQSxXQUFXO1lBQ3ZELE9BQU87UUFDVDtRQUVBLE1BQU1FLE1BQU1DLEtBQUtELEdBQUc7UUFDcEJJLFlBQVlMLEtBQUssR0FBRztRQUNwQkssWUFBWVEsc0JBQXNCLEdBQUdaO1FBQ3JDSSxZQUFZRSxZQUFZLEdBQUdOO1FBQzNCSSxZQUFZRyxTQUFTLEdBQUdQLE1BQU1OO1FBRTlCLElBQUksQ0FBQ2Ms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Z0I7UUFDM0MsTUFBTThCLFFBQVE3QixLQUFLOEIsS0FBSyxDQUFDRixnQkFBaUIsTUFBSyxLQUFLLElBQUc7UUFDdkQsTUFBTUcsVUFBVS9CLEtBQUs4QixLQUFLLENBQUMsZ0JBQWtCLE1BQUssS0FBSyxJQUFHLElBQU8sTUFBSyxJQUFHO1FBRXpFLE9BQU87WUFDTEgsVUFBVTtZQUNWaEQsT0FBT0ssWUFBWUwsS0FBSztZQUN4QmlELGVBQWUsR0FBYUcsT0FBVkYsT0FBTSxNQUFZLE9BQVJFLFNBQVE7WUFDcEM1QyxXQUFXLElBQUlOLEtBQUtHLFlBQVlHLFNBQVM7UUFDM0M7SUFDRjtBQUNGO0FBNVBhWCxlQUNJOEIsY0FBYztBQURsQjlCLGVBRUl1QyxpQkFBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zZXJ2aWNlcy9TZXNzaW9uU2VydmljZS50cz9kNTVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTZXNzaW9uU2VydmljZSAtIENsaWVudC1zaWRlIHNlc3Npb24gbWFuYWdlbWVudCB3aXRoIHBoYXNlLWJhc2VkIGV4cGlyYXRpb25cclxuICogSGFuZGxlcyBkaWZmZXJlbnQgc2Vzc2lvbiBwaGFzZXMgKGNvcmUgdnMgZXh0ZW5kZWQpIHdpdGggYXBwcm9wcmlhdGUgdGltZW91dHNcclxuICovXHJcblxyXG5pbXBvcnQgdHlwZSB7IEFzc2Vzc21lbnRTdGF0ZSB9IGZyb20gJy4uL3N0b3Jlcy9hc3Nlc3NtZW50LXN0b3JlJztcclxuXHJcbi8vIFNlc3Npb24gdGltZW91dCBjb25zdGFudHNcclxuY29uc3QgQ09SRV9TRVNTSU9OX1RJTUVPVVQgPSAzICogNjAgKiA2MCAqIDEwMDA7IC8vIDMgaG91cnNcclxuY29uc3QgRVhURU5ERURfU0VTU0lPTl9USU1FT1VUID0gNDggKiA2MCAqIDYwICogMTAwMDsgLy8gNDggaG91cnNcclxuY29uc3QgU0VTU0lPTl9FWFRFTlNJT05fSU5URVJWQUwgPSA1ICogNjAgKiAxMDAwOyAvLyA1IG1pbnV0ZXNcclxuXHJcbi8vIFNlc3Npb24gcGhhc2UgdHlwZXNcclxuZXhwb3J0IHR5cGUgU2Vzc2lvblBoYXNlID0gJ2NvcmUnIHwgJ2V4dGVuZGVkJztcclxuXHJcbmludGVyZmFjZSBTZXNzaW9uRGF0YSB7XHJcbiAgc2Vzc2lvbklkOiBzdHJpbmc7XHJcbiAgcGhhc2U6IFNlc3Npb25QaGFzZTtcclxuICBjcmVhdGVkQXQ6IG51bWJlcjtcclxuICBsYXN0QWN0aXZlQXQ6IG51bWJlcjtcclxuICBleHBpcmVzQXQ6IG51bWJlcjtcclxuICBleHRlbmRlZFBoYXNlU3RhcnRlZEF0PzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2Vzc2lvblNlcnZpY2Uge1xyXG4gIHByaXZhdGUgc3RhdGljIFNFU1NJT05fS0VZID0gJ21idGktc2Vzc2lvbi1kYXRhJztcclxuICBwcml2YXRlIHN0YXRpYyBleHRlbnNpb25UaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBzZXNzaW9uXHJcbiAgICovXHJcbiAgc3RhdGljIGluaXRpYWxpemVTZXNzaW9uKHNlc3Npb25JZDogc3RyaW5nLCBwaGFzZTogU2Vzc2lvblBoYXNlID0gJ2NvcmUnKTogU2Vzc2lvbkRhdGEge1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmdldFRpbWVvdXRGb3JQaGFzZShwaGFzZSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHNlc3Npb25EYXRhOiBTZXNzaW9uRGF0YSA9IHtcclxuICAgICAgc2Vzc2lvbklkLFxyXG4gICAgICBwaGFzZSxcclxuICAgICAgY3JlYXRlZEF0OiBub3csXHJcbiAgICAgIGxhc3RBY3RpdmVBdDogbm93LFxyXG4gICAgICBleHBpcmVzQXQ6IG5vdyArIHRpbWVvdXQsXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2F2ZVNlc3Npb25EYXRhKHNlc3Npb25EYXRhKTtcclxuICAgIHRoaXMuc3RhcnRBdXRvRXh0ZW5zaW9uKCk7XHJcbiAgICBcclxuICAgIHJldHVybiBzZXNzaW9uRGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aW1lb3V0IGR1cmF0aW9uIGZvciBhIHNwZWNpZmljIHBoYXNlXHJcbiAgICovXHJcbiAgc3RhdGljIGdldFRpbWVvdXRGb3JQaGFzZShwaGFzZTogU2Vzc2lvblBoYXNlKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBwaGFzZSA9PT0gJ2V4dGVuZGVkJyA/IEVYVEVOREVEX1NFU1NJT05fVElNRU9VVCA6IENPUkVfU0VTU0lPTl9USU1FT1VUO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNpdGlvbiBzZXNzaW9uIHRvIGV4dGVuZGVkIHBoYXNlIChhZnRlciBmb3JtYXQgc2VsZWN0aW9uKVxyXG4gICAqL1xyXG4gIHN0YXRpYyB0cmFuc2l0aW9uVG9FeHRlbmRlZFBoYXNlKHNlc3Npb25JZDogc3RyaW5nKTogU2Vzc2lvbkRhdGEgfCBudWxsIHtcclxuICAgIGNvbnN0IHNlc3Npb25EYXRhID0gdGhpcy5nZXRTZXNzaW9uRGF0YSgpO1xyXG4gICAgXHJcbiAgICBpZiAoIXNlc3Npb25EYXRhIHx8IHNlc3Npb25EYXRhLnNlc3Npb25JZCAhPT0gc2Vzc2lvbklkKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBzZXNzaW9uRGF0YS5waGFzZSA9ICdleHRlbmRlZCc7XHJcbiAgICBzZXNzaW9uRGF0YS5leHRlbmRlZFBoYXNlU3RhcnRlZEF0ID0gbm93O1xyXG4gICAgc2Vzc2lvbkRhdGEubGFzdEFjdGl2ZUF0ID0gbm93O1xyXG4gICAgc2Vzc2lvbkRhdGEuZXhwaXJlc0F0ID0gbm93ICsgRVhURU5ERURfU0VTU0lPTl9USU1FT1VUO1xyXG5cclxuICAgIHRoaXMuc2F2ZVNlc3Npb25EYXRhKHNlc3Npb25EYXRhKTtcclxuICAgIHJldHVybiBzZXNzaW9uRGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBzZXNzaW9uIGFjdGl2aXR5IChleHRlbmRzIGV4cGlyYXRpb24gZHVyaW5nIGFjdGl2ZSB1c2UpXHJcbiAgICovXHJcbiAgc3RhdGljIHVwZGF0ZUFjdGl2aXR5KCk6IHZvaWQge1xyXG4gICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSB0aGlzLmdldFNlc3Npb25EYXRhKCk7XHJcbiAgICBcclxuICAgIGlmICghc2Vzc2lvbkRhdGEgfHwgdGhpcy5pc1Nlc3Npb25FeHBpcmVkKHNlc3Npb25EYXRhKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIHNlc3Npb25EYXRhLmxhc3RBY3RpdmVBdCA9IG5vdztcclxuICAgIFxyXG4gICAgLy8gT25seSBleHRlbmQgaWYgYWN0aXZlbHkgYmVpbmcgdXNlZCAod2l0aGluIGxhc3QgNSBtaW51dGVzKVxyXG4gICAgaWYgKHNlc3Npb25EYXRhLnBoYXNlID09PSAnZXh0ZW5kZWQnKSB7XHJcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RBY3Rpdml0eSA9IG5vdyAtIHNlc3Npb25EYXRhLmxhc3RBY3RpdmVBdDtcclxuICAgICAgaWYgKHRpbWVTaW5jZUxhc3RBY3Rpdml0eSA8IFNFU1NJT05fRVhURU5TSU9OX0lOVEVSVkFMKSB7XHJcbiAgICAgICAgLy8gRXh0ZW5kIGJ5IGFub3RoZXIgNDggaG91cnMgZnJvbSBub3dcclxuICAgICAgICBzZXNzaW9uRGF0YS5leHBpcmVzQXQgPSBub3cgKyBFWFRFTkRFRF9TRVNTSU9OX1RJTUVPVVQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNhdmVTZXNzaW9uRGF0YShzZXNzaW9uRGF0YSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBzZXNzaW9uIGlzIGluIGV4dGVuZGVkIHBoYXNlXHJcbiAgICovXHJcbiAgc3RhdGljIGlzRXh0ZW5kZWRQaGFzZSgpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHNlc3Npb25EYXRhID0gdGhpcy5nZXRTZXNzaW9uRGF0YSgpO1xyXG4gICAgcmV0dXJuIHNlc3Npb25EYXRhPy5waGFzZSA9PT0gJ2V4dGVuZGVkJyB8fCBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IHNlc3Npb24gcGhhc2VcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0Q3VycmVudFBoYXNlKCk6IFNlc3Npb25QaGFzZSB8IG51bGwge1xyXG4gICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSB0aGlzLmdldFNlc3Npb25EYXRhKCk7XHJcbiAgICByZXR1cm4gc2Vzc2lvbkRhdGE/LnBoYXNlIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBzZXNzaW9uIGhhcyBleHBpcmVkXHJcbiAgICovXHJcbiAgc3RhdGljIGlzU2Vzc2lvbkV4cGlyZWQoc2Vzc2lvbkRhdGE/OiBTZXNzaW9uRGF0YSB8IG51bGwpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGRhdGEgPSBzZXNzaW9uRGF0YSB8fCB0aGlzLmdldFNlc3Npb25EYXRhKCk7XHJcbiAgICBcclxuICAgIGlmICghZGF0YSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gRGF0ZS5ub3coKSA+IGRhdGEuZXhwaXJlc0F0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRpbWUgcmVtYWluaW5nIGZvciBjdXJyZW50IHNlc3Npb25cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0VGltZVJlbWFpbmluZygpOiBudW1iZXIge1xyXG4gICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSB0aGlzLmdldFNlc3Npb25EYXRhKCk7XHJcbiAgICBcclxuICAgIGlmICghc2Vzc2lvbkRhdGEgfHwgdGhpcy5pc1Nlc3Npb25FeHBpcmVkKHNlc3Npb25EYXRhKSkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgc2Vzc2lvbkRhdGEuZXhwaXJlc0F0IC0gRGF0ZS5ub3coKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhbiB1cCBleHBpcmVkIHNlc3Npb25cclxuICAgKi9cclxuICBzdGF0aWMgY2xlYW51cEV4cGlyZWRTZXNzaW9uKCk6IHZvaWQge1xyXG4gICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSB0aGlzLmdldFNlc3Npb25EYXRhKCk7XHJcbiAgICBcclxuICAgIGlmIChzZXNzaW9uRGF0YSAmJiB0aGlzLmlzU2Vzc2lvbkV4cGlyZWQoc2Vzc2lvbkRhdGEpKSB7XHJcbiAgICAgIHRoaXMuY2xlYXJTZXNzaW9uRGF0YSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHNlc3Npb24gZGF0YSBmcm9tIHN0b3JhZ2VcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0U2Vzc2lvbkRhdGEoKTogU2Vzc2lvbkRhdGEgfCBudWxsIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlNFU1NJT05fS0VZKTtcclxuICAgICAgaWYgKCFkYXRhKSByZXR1cm4gbnVsbDtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpIGFzIFNlc3Npb25EYXRhO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2F2ZSBzZXNzaW9uIGRhdGEgdG8gc3RvcmFnZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RhdGljIHNhdmVTZXNzaW9uRGF0YShkYXRhOiBTZXNzaW9uRGF0YSk6IHZvaWQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5TRVNTSU9OX0tFWSwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgc2Vzc2lvbiBkYXRhOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyIHNlc3Npb24gZGF0YVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjbGVhclNlc3Npb25EYXRhKCk6IHZvaWQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5TRVNTSU9OX0tFWSk7XHJcbiAgICAgIHRoaXMuc3RvcEF1dG9FeHRlbnNpb24oKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjbGVhciBzZXNzaW9uIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgYXV0b21hdGljIHNlc3Npb24gZXh0ZW5zaW9uIHRpbWVyXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgc3RhcnRBdXRvRXh0ZW5zaW9uKCk6IHZvaWQge1xyXG4gICAgdGhpcy5zdG9wQXV0b0V4dGVuc2lvbigpO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBldmVyeSA1IG1pbnV0ZXMgZm9yIGFjdGl2aXR5LWJhc2VkIGV4dGVuc2lvblxyXG4gICAgdGhpcy5leHRlbnNpb25UaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgdGhpcy51cGRhdGVBY3Rpdml0eSgpO1xyXG4gICAgfSwgU0VTU0lPTl9FWFRFTlNJT05fSU5URVJWQUwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBhdXRvbWF0aWMgc2Vzc2lvbiBleHRlbnNpb24gdGltZXJcclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBzdG9wQXV0b0V4dGVuc2lvbigpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmV4dGVuc2lvblRpbWVyKSB7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5leHRlbnNpb25UaW1lcik7XHJcbiAgICAgIHRoaXMuZXh0ZW5zaW9uVGltZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGUgYXNzZXNzbWVudCBzdGF0ZSBtYXRjaGVzIHNlc3Npb25cclxuICAgKi9cclxuICBzdGF0aWMgdmFsaWRhdGVTZXNzaW9uU3RhdGUoYXNzZXNzbWVudFN0YXRlOiBBc3Nlc3NtZW50U3RhdGUpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHNlc3Npb25EYXRhID0gdGhpcy5nZXRTZXNzaW9uRGF0YSgpO1xyXG4gICAgXHJcbiAgICBpZiAoIXNlc3Npb25EYXRhKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiBzZXNzaW9uIElEcyBtYXRjaFxyXG4gICAgaWYgKGFzc2Vzc21lbnRTdGF0ZS5zZXNzaW9uSWQgIT09IHNlc3Npb25EYXRhLnNlc3Npb25JZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgc2Vzc2lvbiBoYXMgZXhwaXJlZFxyXG4gICAgaWYgKHRoaXMuaXNTZXNzaW9uRXhwaXJlZChzZXNzaW9uRGF0YSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkYXRlIHBoYXNlIGNvbnNpc3RlbmN5XHJcbiAgICBjb25zdCBoYXNTZWxlY3RlZEZvcm1hdCA9IGFzc2Vzc21lbnRTdGF0ZS5zZWxlY3RlZEZvcm1hdCAhPT0gbnVsbCAmJiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhc3Nlc3NtZW50U3RhdGUuY3VycmVudFN0ZXAgPT09ICdxdWVzdGlvbnMnIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2Vzc21lbnRTdGF0ZS5jdXJyZW50U3RlcCA9PT0gJ3Jlc3VsdHMnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXNzbWVudFN0YXRlLmN1cnJlbnRTdGVwID09PSAnY29hY2hpbmcnKTtcclxuICAgIGNvbnN0IHNob3VsZEJlRXh0ZW5kZWQgPSBoYXNTZWxlY3RlZEZvcm1hdCAmJiBzZXNzaW9uRGF0YS5waGFzZSA9PT0gJ2V4dGVuZGVkJztcclxuICAgIGNvbnN0IHNob3VsZEJlQ29yZSA9ICFoYXNTZWxlY3RlZEZvcm1hdCAmJiBzZXNzaW9uRGF0YS5waGFzZSA9PT0gJ2NvcmUnO1xyXG5cclxuICAgIHJldHVybiBzaG91bGRCZUV4dGVuZGVkIHx8IHNob3VsZEJlQ29yZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBzZXNzaW9uIHN1bW1hcnkgZm9yIGRlYnVnZ2luZy9VSVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRTZXNzaW9uU3VtbWFyeSgpOiB7XHJcbiAgICBpc0FjdGl2ZTogYm9vbGVhbjtcclxuICAgIHBoYXNlOiBTZXNzaW9uUGhhc2UgfCBudWxsO1xyXG4gICAgdGltZVJlbWFpbmluZzogc3RyaW5nO1xyXG4gICAgZXhwaXJlc0F0OiBEYXRlIHwgbnVsbDtcclxuICB9IHtcclxuICAgIGNvbnN0IHNlc3Npb25EYXRhID0gdGhpcy5nZXRTZXNzaW9uRGF0YSgpO1xyXG4gICAgY29uc3QgaXNFeHBpcmVkID0gdGhpcy5pc1Nlc3Npb25FeHBpcmVkKHNlc3Npb25EYXRhKTtcclxuICAgIFxyXG4gICAgaWYgKCFzZXNzaW9uRGF0YSB8fCBpc0V4cGlyZWQpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgcGhhc2U6IG51bGwsXHJcbiAgICAgICAgdGltZVJlbWFpbmluZzogJzBoIDBtJyxcclxuICAgICAgICBleHBpcmVzQXQ6IG51bGwsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGltZVJlbWFpbmluZyA9IHRoaXMuZ2V0VGltZVJlbWFpbmluZygpO1xyXG4gICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHRpbWVSZW1haW5pbmcgLyAoNjAgKiA2MCAqIDEwMDApKTtcclxuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKCh0aW1lUmVtYWluaW5nICUgKDYwICogNjAgKiAxMDAwKSkgLyAoNjAgKiAxMDAwKSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaXNBY3RpdmU6IHRydWUsXHJcbiAgICAgIHBoYXNlOiBzZXNzaW9uRGF0YS5waGFzZSxcclxuICAgICAgdGltZVJlbWFpbmluZzogYCR7aG91cnN9aCAke21pbnV0ZXN9bWAsXHJcbiAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoc2Vzc2lvbkRhdGEuZXhwaXJlc0F0KSxcclxuICAgIH07XHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbIkNPUkVfU0VTU0lPTl9USU1FT1VUIiwiRVhURU5ERURfU0VTU0lPTl9USU1FT1VUIiwiU0VTU0lPTl9FWFRFTlNJT05fSU5URVJWQUwiLCJTZXNzaW9uU2VydmljZSIsImluaXRpYWxpemVTZXNzaW9uIiwic2Vzc2lvbklkIiwicGhhc2UiLCJub3ciLCJEYXRlIiwidGltZW91dCIsImdldFRpbWVvdXRGb3JQaGFzZSIsInNlc3Npb25EYXRhIiwiY3JlYXRlZEF0IiwibGFzdEFjdGl2ZUF0IiwiZXhwaXJlc0F0Iiwic2F2ZVNlc3Npb25EYXRhIiwic3RhcnRBdXRvRXh0ZW5zaW9uIiwidHJhbnNpdGlvblRvRXh0ZW5kZWRQaGFzZSIsImdldFNlc3Npb25EYXRhIiwiZXh0ZW5kZWRQaGFzZVN0YXJ0ZWRBdCIsInVwZGF0ZUFjdGl2aXR5IiwiaXNTZXNzaW9uRXhwaXJlZCIsInRpbWVTaW5jZUxhc3RBY3Rpdml0eSIsImlzRXh0ZW5kZWRQaGFzZSIsImdldEN1cnJlbnRQaGFzZSIsImRhdGEiLCJnZXRUaW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImNsZWFudXBFeHBpcmVkU2Vzc2lvbiIsImNsZWFyU2Vzc2lvbkRhdGEiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiU0VTU0lPTl9LRVkiLCJKU09OIiwicGFyc2UiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb25zb2xlIiwicmVtb3ZlSXRlbSIsInN0b3BBdXRvRXh0ZW5zaW9uIiwiZXh0ZW5zaW9uVGltZXIiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ2YWxpZGF0ZVNlc3Npb25TdGF0ZSIsImFzc2Vzc21lbnRTdGF0ZSIsImhhc1NlbGVjdGVkRm9ybWF0Iiwic2VsZWN0ZWRGb3JtYXQiLCJjdXJyZW50U3RlcCIsInNob3VsZEJlRXh0ZW5kZWQiLCJzaG91bGRCZUNvcmUiLCJnZXRTZXNzaW9uU3VtbWFyeSIsImlzRXhwaXJlZCIsImlzQWN0aXZlIiwidGltZVJlbWFpbmluZyIsImhvdXJzIiwiZmxvb3IiLCJtaW51dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/SessionService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/services/StorageService.ts":
/*!********************************************!*\
  !*** ./src/lib/services/StorageService.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   storageService: function() { return /* binding */ storageService; }\n/* harmony export */ });\n/* harmony import */ var _OptimizedStorageService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OptimizedStorageService */ \"(app-pages-browser)/./src/lib/services/OptimizedStorageService.ts\");\n\nclass StorageService {\n    /**\r\n   * Check storage layer health\r\n   */ checkStorageHealth() {\n        return {\n            localStorage: this.isLocalStorageAvailable(),\n            sessionStorage: this.isSessionStorageAvailable()\n        };\n    }\n    /**\r\n   * Get item with fallback chain: localStorage -> sessionStorage -> memory\r\n   */ getItem(key) {\n        // Check if this might be optimized SAIS data\n        if (this.mightBeSAISSession(key)) {\n            const saisData = _OptimizedStorageService__WEBPACK_IMPORTED_MODULE_0__.optimizedStorage.retrieveSAISAssessment(key);\n            if (saisData) {\n                return {\n                    success: true,\n                    data: saisData,\n                    layer: \"localStorage\"\n                };\n            }\n        }\n        // Try localStorage first\n        const localResult = this.getFromLocalStorage(key);\n        if (localResult.success) {\n            return {\n                ...localResult,\n                layer: \"localStorage\"\n            };\n        }\n        // Try sessionStorage\n        const sessionResult = this.getFromSessionStorage(key);\n        if (sessionResult.success) {\n            return {\n                ...sessionResult,\n                layer: \"sessionStorage\"\n            };\n        }\n        // Try memory storage\n        const memoryResult = this.getFromMemory(key);\n        if (memoryResult.success) {\n            return {\n                ...memoryResult,\n                layer: \"memory\"\n            };\n        }\n        return {\n            success: false,\n            error: \"Item not found in any storage layer\",\n            layer: \"memory\"\n        };\n    }\n    /**\r\n   * Set item across available storage layers with graceful fallback\r\n   */ setItem(key, value) {\n        // Check if this is SAIS assessment data that needs optimization\n        if (this.isSAISAssessmentData(key, value)) {\n            const optimized = _OptimizedStorageService__WEBPACK_IMPORTED_MODULE_0__.optimizedStorage.storeSAISAssessment(key, value);\n            if (optimized) {\n                return {\n                    success: true,\n                    data: {\n                        savedTo: 1,\n                        layers: \"optimized\",\n                        optimization: \"sais-compressed\"\n                    },\n                    layer: \"localStorage\"\n                };\n            }\n        }\n        const serializedValue = JSON.stringify(value);\n        let successCount = 0;\n        const errors = [];\n        // Try localStorage\n        const localResult = this.setToLocalStorage(key, serializedValue);\n        if (localResult.success) {\n            successCount++;\n        } else {\n            errors.push(\"localStorage: \".concat(localResult.error));\n        }\n        // Try sessionStorage\n        const sessionResult = this.setToSessionStorage(key, serializedValue);\n        if (sessionResult.success) {\n            successCount++;\n        } else {\n            errors.push(\"sessionStorage: \".concat(sessionResult.error));\n        }\n        // Always set in memory as final fallback\n        this.memoryStorage.set(key, serializedValue);\n        successCount++;\n        return {\n            success: successCount > 0,\n            data: {\n                savedTo: successCount,\n                layers: successCount === 3 ? \"all\" : \"partial\",\n                errors: errors.length > 0 ? errors : undefined\n            }\n        };\n    }\n    /**\r\n   * Remove item from all storage layers\r\n   */ removeItem(key) {\n        let successCount = 0;\n        // Clean up optimized SAIS data if exists\n        if (this.mightBeSAISSession(key)) {\n            _OptimizedStorageService__WEBPACK_IMPORTED_MODULE_0__.optimizedStorage.cleanupSAISData(key);\n        }\n        // Remove from localStorage\n        if (this.isLocalStorageAvailable()) {\n            try {\n                localStorage.removeItem(key);\n                successCount++;\n            } catch (error) {\n            // Ignore localStorage removal errors\n            }\n        }\n        // Remove from sessionStorage\n        if (this.isSessionStorageAvailable()) {\n            try {\n                sessionStorage.removeItem(key);\n                successCount++;\n            } catch (error) {\n            // Ignore sessionStorage removal errors\n            }\n        }\n        // Remove from memory\n        this.memoryStorage.delete(key);\n        successCount++;\n        return {\n            success: true,\n            data: {\n                removedFrom: successCount\n            }\n        };\n    }\n    /**\r\n   * Clear all stored data\r\n   */ clear() {\n        let successCount = 0;\n        // Clear localStorage\n        if (this.isLocalStorageAvailable()) {\n            try {\n                localStorage.clear();\n                successCount++;\n            } catch (error) {\n            // Ignore localStorage clear errors\n            }\n        }\n        // Clear sessionStorage\n        if (this.isSessionStorageAvailable()) {\n            try {\n                sessionStorage.clear();\n                successCount++;\n            } catch (error) {\n            // Ignore sessionStorage clear errors\n            }\n        }\n        // Clear memory\n        this.memoryStorage.clear();\n        successCount++;\n        return {\n            success: true,\n            data: {\n                clearedLayers: successCount\n            }\n        };\n    }\n    // Private methods for individual storage layers\n    isLocalStorageAvailable() {\n        try {\n            if (false) {}\n            const testKey = \"__storage_test__\";\n            localStorage.setItem(testKey, \"test\");\n            localStorage.removeItem(testKey);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    isSessionStorageAvailable() {\n        try {\n            if (false) {}\n            const testKey = \"__storage_test__\";\n            sessionStorage.setItem(testKey, \"test\");\n            sessionStorage.removeItem(testKey);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    getFromLocalStorage(key) {\n        try {\n            if (!this.isLocalStorageAvailable()) {\n                return {\n                    success: false,\n                    error: \"localStorage not available\"\n                };\n            }\n            const item = localStorage.getItem(key);\n            if (item === null) {\n                return {\n                    success: false,\n                    error: \"Item not found\"\n                };\n            }\n            return {\n                success: true,\n                data: JSON.parse(item)\n            };\n        } catch (error) {\n            if (error instanceof Error && error.name === \"QuotaExceededError\") {\n                return {\n                    success: false,\n                    error: \"Storage quota exceeded\"\n                };\n            }\n            return {\n                success: false,\n                error: \"localStorage read error\"\n            };\n        }\n    }\n    getFromSessionStorage(key) {\n        try {\n            if (!this.isSessionStorageAvailable()) {\n                return {\n                    success: false,\n                    error: \"sessionStorage not available\"\n                };\n            }\n            const item = sessionStorage.getItem(key);\n            if (item === null) {\n                return {\n                    success: false,\n                    error: \"Item not found\"\n                };\n            }\n            return {\n                success: true,\n                data: JSON.parse(item)\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: \"sessionStorage read error\"\n            };\n        }\n    }\n    getFromMemory(key) {\n        try {\n            const item = this.memoryStorage.get(key);\n            if (!item) {\n                return {\n                    success: false,\n                    error: \"Item not found in memory\"\n                };\n            }\n            return {\n                success: true,\n                data: JSON.parse(item)\n            };\n        } catch (error) {\n            return {\n                success: false,\n                error: \"Memory storage read error\"\n            };\n        }\n    }\n    setToLocalStorage(key, value) {\n        try {\n            if (!this.isLocalStorageAvailable()) {\n                return {\n                    success: false,\n                    error: \"localStorage not available\"\n                };\n            }\n            localStorage.setItem(key, value);\n            return {\n                success: true\n            };\n        } catch (error) {\n            if (error instanceof Error && error.name === \"QuotaExceededError\") {\n                // Try to free up space by removing old items\n                this.cleanupOldStorageItems(\"localStorage\");\n                try {\n                    localStorage.setItem(key, value);\n                    return {\n                        success: true\n                    };\n                } catch (e) {\n                    return {\n                        success: false,\n                        error: \"Storage quota exceeded after cleanup\"\n                    };\n                }\n            }\n            return {\n                success: false,\n                error: \"localStorage write error\"\n            };\n        }\n    }\n    setToSessionStorage(key, value) {\n        try {\n            if (!this.isSessionStorageAvailable()) {\n                return {\n                    success: false,\n                    error: \"sessionStorage not available\"\n                };\n            }\n            sessionStorage.setItem(key, value);\n            return {\n                success: true\n            };\n        } catch (error) {\n            if (error instanceof Error && error.name === \"QuotaExceededError\") {\n                return {\n                    success: false,\n                    error: \"Storage quota exceeded\"\n                };\n            }\n            return {\n                success: false,\n                error: \"sessionStorage write error\"\n            };\n        }\n    }\n    cleanupOldStorageItems(storageType) {\n        try {\n            const storage = storageType === \"localStorage\" ? localStorage : sessionStorage;\n            const keys = Object.keys(storage);\n            // Remove oldest items (simple strategy - remove first half of items)\n            const itemsToRemove = Math.ceil(keys.length / 2);\n            for(let i = 0; i < itemsToRemove; i++){\n                storage.removeItem(keys[i]);\n            }\n        } catch (e) {\n        // Ignore cleanup errors\n        }\n    }\n    /**\r\n   * Check if data is SAIS assessment that needs optimization\r\n   */ isSAISAssessmentData(key, value) {\n        var _value_extendedResponses;\n        return key.startsWith(\"session-\") && (value === null || value === void 0 ? void 0 : value.selectedFormat) === \"sais\" && (value === null || value === void 0 ? void 0 : (_value_extendedResponses = value.extendedResponses) === null || _value_extendedResponses === void 0 ? void 0 : _value_extendedResponses.length) > 0;\n    }\n    /**\r\n   * Check if key might be a SAIS session\r\n   */ mightBeSAISSession(key) {\n        return key.startsWith(\"session-\");\n    }\n    /**\r\n   * Get storage health including SAIS optimization metrics\r\n   */ getExtendedHealth() {\n        const baseHealth = this.checkStorageHealth();\n        const saisHealth = _OptimizedStorageService__WEBPACK_IMPORTED_MODULE_0__.optimizedStorage.checkSAISStorageHealth();\n        return {\n            ...baseHealth,\n            saisOptimization: saisHealth\n        };\n    }\n    // Cleanup method for component unmounting\n    destroy() {\n        this.memoryStorage.clear();\n    }\n    constructor(){\n        this.memoryStorage = new Map();\n    }\n}\n// Export singleton instance\nconst storageService = new StorageService();\n/* harmony default export */ __webpack_exports__[\"default\"] = (storageService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvU3RvcmFnZVNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEQ7QUFnQjVELE1BQU1DO0lBR0o7O0dBRUMsR0FDREMscUJBQW9DO1FBQ2xDLE9BQU87WUFDTEMsY0FBYyxJQUFJLENBQUNDLHVCQUF1QjtZQUMxQ0MsZ0JBQWdCLElBQUksQ0FBQ0MseUJBQXlCO1FBQ2hEO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEQyxRQUFpQkMsR0FBVyxFQUFvQjtRQUM5Qyw2Q0FBNkM7UUFDN0MsSUFBSSxJQUFJLENBQUNDLGtCQUFrQixDQUFDRCxNQUFNO1lBQ2hDLE1BQU1FLFdBQVdWLHNFQUFnQkEsQ0FBQ1csc0JBQXNCLENBQUNIO1lBQ3pELElBQUlFLFVBQVU7Z0JBQ1osT0FBTztvQkFDTEUsU0FBUztvQkFDVEMsTUFBTUg7b0JBQ05JLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO1FBRUEseUJBQXlCO1FBQ3pCLE1BQU1DLGNBQWMsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBSVI7UUFDaEQsSUFBSU8sWUFBWUgsT0FBTyxFQUFFO1lBQ3ZCLE9BQU87Z0JBQUUsR0FBR0csV0FBVztnQkFBRUQsT0FBTztZQUFlO1FBQ2pEO1FBRUEscUJBQXFCO1FBQ3JCLE1BQU1HLGdCQUFnQixJQUFJLENBQUNDLHFCQUFxQixDQUFJVjtRQUNwRCxJQUFJUyxjQUFjTCxPQUFPLEVBQUU7WUFDekIsT0FBTztnQkFBRSxHQUFHSyxhQUFhO2dCQUFFSCxPQUFPO1lBQWlCO1FBQ3JEO1FBRUEscUJBQXFCO1FBQ3JCLE1BQU1LLGVBQWUsSUFBSSxDQUFDQyxhQUFhLENBQUlaO1FBQzNDLElBQUlXLGFBQWFQLE9BQU8sRUFBRTtZQUN4QixPQUFPO2dCQUFFLEdBQUdPLFlBQVk7Z0JBQUVMLE9BQU87WUFBUztRQUM1QztRQUVBLE9BQU87WUFDTEYsU0FBUztZQUNUUyxPQUFPO1lBQ1BQLE9BQU87UUFDVDtJQUNGO0lBRUE7O0dBRUMsR0FD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QjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxxQkFBNkJ0RCxHQUFXLEVBQUVlLEtBQVUsRUFBVztZQUd0REE7UUFGUCxPQUFPZixJQUFJdUQsVUFBVSxDQUFDLGVBQ2Z4QyxDQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU95QyxjQUFjLE1BQUssVUFDMUJ6QyxDQUFBQSxrQkFBQUEsNkJBQUFBLDJCQUFBQSxNQUFPMEMsaUJBQWlCLGNBQXhCMUMsK0NBQUFBLHlCQUEwQmlCLE1BQU0sSUFBRztJQUM1QztJQUVBOztHQUVDLEdBQ0QsbUJBQTJCaEMsR0FBVyxFQUFXO1FBQy9DLE9BQU9BLElBQUl1RCxVQUFVLENBQUM7SUFDeEI7SUFFQTs7R0FFQyxHQUNERyxvQkFBZ0U7UUFDOUQsTUFBTUMsYUFBYSxJQUFJLENBQUNqRSxrQkFBa0I7UUFDMUMsTUFBTWtFLGFBQWFwRSxzRUFBZ0JBLENBQUNxRSxzQkFBc0I7UUFFMUQsT0FBTztZQUNMLEdBQUdGLFVBQVU7WUFDYkcsa0JBQWtCRjtRQUNwQjtJQUNGO0lBRUEsMENBQTBDO0lBQzFDRyxVQUFnQjtRQUNkLElBQUksQ0FBQ2pDLGFBQWEsQ0FBQ1EsS0FBSztJQUMxQjs7YUF0V1FSLGdCQUFnQixJQUFJa0M7O0FBdVc5QjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNQyxpQkFBaUIsSUFBSXhFLGlCQUFnQjtBQUNsRCwrREFBZXdFLGNBQWNBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zZXJ2aWNlcy9TdG9yYWdlU2VydmljZS50cz84MjZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9wdGltaXplZFN0b3JhZ2UgfSBmcm9tICcuL09wdGltaXplZFN0b3JhZ2VTZXJ2aWNlJ1xyXG5cclxudHlwZSBTdG9yYWdlTGF5ZXIgPSAnbG9jYWxTdG9yYWdlJyB8ICdzZXNzaW9uU3RvcmFnZScgfCAnbWVtb3J5J1xyXG5cclxuaW50ZXJmYWNlIFN0b3JhZ2VSZXN1bHQ8VCA9IGFueT4ge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW5cclxuICBkYXRhPzogVFxyXG4gIGVycm9yPzogc3RyaW5nXHJcbiAgbGF5ZXI/OiBTdG9yYWdlTGF5ZXJcclxufVxyXG5cclxuaW50ZXJmYWNlIFN0b3JhZ2VIZWFsdGgge1xyXG4gIGxvY2FsU3RvcmFnZTogYm9vbGVhblxyXG4gIHNlc3Npb25TdG9yYWdlOiBib29sZWFuXHJcbn1cclxuXHJcbmNsYXNzIFN0b3JhZ2VTZXJ2aWNlIHtcclxuICBwcml2YXRlIG1lbW9yeVN0b3JhZ2UgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIHN0b3JhZ2UgbGF5ZXIgaGVhbHRoXHJcbiAgICovXHJcbiAgY2hlY2tTdG9yYWdlSGVhbHRoKCk6IFN0b3JhZ2VIZWFsdGgge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbG9jYWxTdG9yYWdlOiB0aGlzLmlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCksXHJcbiAgICAgIHNlc3Npb25TdG9yYWdlOiB0aGlzLmlzU2Vzc2lvblN0b3JhZ2VBdmFpbGFibGUoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGl0ZW0gd2l0aCBmYWxsYmFjayBjaGFpbjogbG9jYWxTdG9yYWdlIC0+IHNlc3Npb25TdG9yYWdlIC0+IG1lbW9yeVxyXG4gICAqL1xyXG4gIGdldEl0ZW08VCA9IGFueT4oa2V5OiBzdHJpbmcpOiBTdG9yYWdlUmVzdWx0PFQ+IHtcclxuICAgIC8vIENoZWNrIGlmIHRoaXMgbWlnaHQgYmUgb3B0aW1pemVkIFNBSVMgZGF0YVxyXG4gICAgaWYgKHRoaXMubWlnaHRCZVNBSVNTZXNzaW9uKGtleSkpIHtcclxuICAgICAgY29uc3Qgc2Fpc0RhdGEgPSBvcHRpbWl6ZWRTdG9yYWdlLnJldHJpZXZlU0FJU0Fzc2Vzc21lbnQoa2V5KVxyXG4gICAgICBpZiAoc2Fpc0RhdGEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICAgIGRhdGE6IHNhaXNEYXRhIGFzIFQsXHJcbiAgICAgICAgICBsYXllcjogJ2xvY2FsU3RvcmFnZSdcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVHJ5IGxvY2FsU3RvcmFnZSBmaXJzdFxyXG4gICAgY29uc3QgbG9jYWxSZXN1bHQgPSB0aGlzLmdldEZyb21Mb2NhbFN0b3JhZ2U8VD4oa2V5KVxyXG4gICAgaWYgKGxvY2FsUmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgcmV0dXJuIHsgLi4ubG9jYWxSZXN1bHQsIGxheWVyOiAnbG9jYWxTdG9yYWdlJyB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IHNlc3Npb25TdG9yYWdlXHJcbiAgICBjb25zdCBzZXNzaW9uUmVzdWx0ID0gdGhpcy5nZXRGcm9tU2Vzc2lvblN0b3JhZ2U8VD4oa2V5KVxyXG4gICAgaWYgKHNlc3Npb25SZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICByZXR1cm4geyAuLi5zZXNzaW9uUmVzdWx0LCBsYXllcjogJ3Nlc3Npb25TdG9yYWdlJyB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IG1lbW9yeSBzdG9yYWdlXHJcbiAgICBjb25zdCBtZW1vcnlSZXN1bHQgPSB0aGlzLmdldEZyb21NZW1vcnk8VD4oa2V5KVxyXG4gICAgaWYgKG1lbW9yeVJlc3VsdC5zdWNjZXNzKSB7XHJcbiAgICAgIHJldHVybiB7IC4uLm1lbW9yeVJlc3VsdCwgbGF5ZXI6ICdtZW1vcnknIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgZXJyb3I6ICdJdGVtIG5vdCBmb3VuZCBpbiBhbnkgc3RvcmFnZSBsYXllcicsXHJcbiAgICAgIGxheWVyOiAnbWVtb3J5J1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGl0ZW0gYWNyb3NzIGF2YWlsYWJsZSBzdG9yYWdlIGxheWVycyB3aXRoIGdyYWNlZnVsIGZhbGxiYWNrXHJcbiAgICovXHJcbiAgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IGFueSk6IFN0b3JhZ2VSZXN1bHQge1xyXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBTQUlTIGFzc2Vzc21lbnQgZGF0YSB0aGF0IG5lZWRzIG9wdGltaXphdGlvblxyXG4gICAgaWYgKHRoaXMuaXNTQUlTQXNzZXNzbWVudERhdGEoa2V5LCB2YWx1ZSkpIHtcclxuICAgICAgY29uc3Qgb3B0aW1pemVkID0gb3B0aW1pemVkU3RvcmFnZS5zdG9yZVNBSVNBc3Nlc3NtZW50KGtleSwgdmFsdWUpXHJcbiAgICAgIGlmIChvcHRpbWl6ZWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICAgIGRhdGE6IHsgXHJcbiAgICAgICAgICAgIHNhdmVkVG86IDEsXHJcbiAgICAgICAgICAgIGxheWVyczogJ29wdGltaXplZCcsXHJcbiAgICAgICAgICAgIG9wdGltaXphdGlvbjogJ3NhaXMtY29tcHJlc3NlZCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBsYXllcjogJ2xvY2FsU3RvcmFnZSdcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpXHJcbiAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMFxyXG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdXHJcblxyXG4gICAgLy8gVHJ5IGxvY2FsU3RvcmFnZVxyXG4gICAgY29uc3QgbG9jYWxSZXN1bHQgPSB0aGlzLnNldFRvTG9jYWxTdG9yYWdlKGtleSwgc2VyaWFsaXplZFZhbHVlKVxyXG4gICAgaWYgKGxvY2FsUmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgc3VjY2Vzc0NvdW50KytcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVycm9ycy5wdXNoKGBsb2NhbFN0b3JhZ2U6ICR7bG9jYWxSZXN1bHQuZXJyb3J9YClcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgc2Vzc2lvblN0b3JhZ2VcclxuICAgIGNvbnN0IHNlc3Npb25SZXN1bHQgPSB0aGlzLnNldFRvU2Vzc2lvblN0b3JhZ2Uoa2V5LCBzZXJpYWxpemVkVmFsdWUpXHJcbiAgICBpZiAoc2Vzc2lvblJlc3VsdC5zdWNjZXNzKSB7XHJcbiAgICAgIHN1Y2Nlc3NDb3VudCsrXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlcnJvcnMucHVzaChgc2Vzc2lvblN0b3JhZ2U6ICR7c2Vzc2lvblJlc3VsdC5lcnJvcn1gKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFsd2F5cyBzZXQgaW4gbWVtb3J5IGFzIGZpbmFsIGZhbGxiYWNrXHJcbiAgICB0aGlzLm1lbW9yeVN0b3JhZ2Uuc2V0KGtleSwgc2VyaWFsaXplZFZhbHVlKVxyXG4gICAgc3VjY2Vzc0NvdW50KytcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiBzdWNjZXNzQ291bnQgPiAwLFxyXG4gICAgICBkYXRhOiB7IFxyXG4gICAgICAgIHNhdmVkVG86IHN1Y2Nlc3NDb3VudCxcclxuICAgICAgICBsYXllcnM6IHN1Y2Nlc3NDb3VudCA9PT0gMyA/ICdhbGwnIDogJ3BhcnRpYWwnLFxyXG4gICAgICAgIGVycm9yczogZXJyb3JzLmxlbmd0aCA+IDAgPyBlcnJvcnMgOiB1bmRlZmluZWRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGl0ZW0gZnJvbSBhbGwgc3RvcmFnZSBsYXllcnNcclxuICAgKi9cclxuICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogU3RvcmFnZVJlc3VsdCB7XHJcbiAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMFxyXG4gICAgXHJcbiAgICAvLyBDbGVhbiB1cCBvcHRpbWl6ZWQgU0FJUyBkYXRhIGlmIGV4aXN0c1xyXG4gICAgaWYgKHRoaXMubWlnaHRCZVNBSVNTZXNzaW9uKGtleSkpIHtcclxuICAgICAgb3B0aW1pemVkU3RvcmFnZS5jbGVhbnVwU0FJU0RhdGEoa2V5KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBmcm9tIGxvY2FsU3RvcmFnZVxyXG4gICAgaWYgKHRoaXMuaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcclxuICAgICAgICBzdWNjZXNzQ291bnQrK1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIC8vIElnbm9yZSBsb2NhbFN0b3JhZ2UgcmVtb3ZhbCBlcnJvcnNcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBmcm9tIHNlc3Npb25TdG9yYWdlXHJcbiAgICBpZiAodGhpcy5pc1Nlc3Npb25TdG9yYWdlQXZhaWxhYmxlKCkpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcclxuICAgICAgICBzdWNjZXNzQ291bnQrK1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIC8vIElnbm9yZSBzZXNzaW9uU3RvcmFnZSByZW1vdmFsIGVycm9yc1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIGZyb20gbWVtb3J5XHJcbiAgICB0aGlzLm1lbW9yeVN0b3JhZ2UuZGVsZXRlKGtleSlcclxuICAgIHN1Y2Nlc3NDb3VudCsrXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgZGF0YTogeyByZW1vdmVkRnJvbTogc3VjY2Vzc0NvdW50IH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyIGFsbCBzdG9yZWQgZGF0YVxyXG4gICAqL1xyXG4gIGNsZWFyKCk6IFN0b3JhZ2VSZXN1bHQge1xyXG4gICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDBcclxuXHJcbiAgICAvLyBDbGVhciBsb2NhbFN0b3JhZ2VcclxuICAgIGlmICh0aGlzLmlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKVxyXG4gICAgICAgIHN1Y2Nlc3NDb3VudCsrXHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgLy8gSWdub3JlIGxvY2FsU3RvcmFnZSBjbGVhciBlcnJvcnNcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENsZWFyIHNlc3Npb25TdG9yYWdlXHJcbiAgICBpZiAodGhpcy5pc1Nlc3Npb25TdG9yYWdlQXZhaWxhYmxlKCkpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5jbGVhcigpXHJcbiAgICAgICAgc3VjY2Vzc0NvdW50KytcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAvLyBJZ25vcmUgc2Vzc2lvblN0b3JhZ2UgY2xlYXIgZXJyb3JzXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDbGVhciBtZW1vcnlcclxuICAgIHRoaXMubWVtb3J5U3RvcmFnZS5jbGVhcigpXHJcbiAgICBzdWNjZXNzQ291bnQrK1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIGRhdGE6IHsgY2xlYXJlZExheWVyczogc3VjY2Vzc0NvdW50IH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFByaXZhdGUgbWV0aG9kcyBmb3IgaW5kaXZpZHVhbCBzdG9yYWdlIGxheWVyc1xyXG5cclxuICBwcml2YXRlIGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2VcclxuICAgICAgY29uc3QgdGVzdEtleSA9ICdfX3N0b3JhZ2VfdGVzdF9fJ1xyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0ZXN0S2V5LCAndGVzdCcpXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RLZXkpXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGlzU2Vzc2lvblN0b3JhZ2VBdmFpbGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZVxyXG4gICAgICBjb25zdCB0ZXN0S2V5ID0gJ19fc3RvcmFnZV90ZXN0X18nXHJcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odGVzdEtleSwgJ3Rlc3QnKVxyXG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RLZXkpXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgcHJpdmF0ZSBnZXRGcm9tTG9jYWxTdG9yYWdlPFQ+KGtleTogc3RyaW5nKTogU3RvcmFnZVJlc3VsdDxUPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIXRoaXMuaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xyXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ2xvY2FsU3RvcmFnZSBub3QgYXZhaWxhYmxlJyB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpXHJcbiAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnSXRlbSBub3QgZm91bmQnIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgIGRhdGE6IEpTT04ucGFyc2UoaXRlbSlcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicpIHtcclxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdTdG9yYWdlIHF1b3RhIGV4Y2VlZGVkJyB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnbG9jYWxTdG9yYWdlIHJlYWQgZXJyb3InIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0RnJvbVNlc3Npb25TdG9yYWdlPFQ+KGtleTogc3RyaW5nKTogU3RvcmFnZVJlc3VsdDxUPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIXRoaXMuaXNTZXNzaW9uU3RvcmFnZUF2YWlsYWJsZSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnc2Vzc2lvblN0b3JhZ2Ugbm90IGF2YWlsYWJsZScgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpdGVtID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpXHJcbiAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnSXRlbSBub3QgZm91bmQnIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgIGRhdGE6IEpTT04ucGFyc2UoaXRlbSlcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnc2Vzc2lvblN0b3JhZ2UgcmVhZCBlcnJvcicgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIHByaXZhdGUgZ2V0RnJvbU1lbW9yeTxUPihrZXk6IHN0cmluZyk6IFN0b3JhZ2VSZXN1bHQ8VD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVtb3J5U3RvcmFnZS5nZXQoa2V5KVxyXG4gICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdJdGVtIG5vdCBmb3VuZCBpbiBtZW1vcnknIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgIGRhdGE6IEpTT04ucGFyc2UoaXRlbSlcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnTWVtb3J5IHN0b3JhZ2UgcmVhZCBlcnJvcicgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzZXRUb0xvY2FsU3RvcmFnZShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IFN0b3JhZ2VSZXN1bHQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCF0aGlzLmlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdsb2NhbFN0b3JhZ2Ugbm90IGF2YWlsYWJsZScgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09ICdRdW90YUV4Y2VlZGVkRXJyb3InKSB7XHJcbiAgICAgICAgLy8gVHJ5IHRvIGZyZWUgdXAgc3BhY2UgYnkgcmVtb3Zpbmcgb2xkIGl0ZW1zXHJcbiAgICAgICAgdGhpcy5jbGVhbnVwT2xkU3RvcmFnZUl0ZW1zKCdsb2NhbFN0b3JhZ2UnKVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxyXG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdTdG9yYWdlIHF1b3RhIGV4Y2VlZGVkIGFmdGVyIGNsZWFudXAnIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnbG9jYWxTdG9yYWdlIHdyaXRlIGVycm9yJyB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNldFRvU2Vzc2lvblN0b3JhZ2Uoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBTdG9yYWdlUmVzdWx0IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICghdGhpcy5pc1Nlc3Npb25TdG9yYWdlQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdzZXNzaW9uU3RvcmFnZSBub3QgYXZhaWxhYmxlJyB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSlcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJykge1xyXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1N0b3JhZ2UgcXVvdGEgZXhjZWVkZWQnIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdzZXNzaW9uU3RvcmFnZSB3cml0ZSBlcnJvcicgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIHByaXZhdGUgY2xlYW51cE9sZFN0b3JhZ2VJdGVtcyhzdG9yYWdlVHlwZTogJ2xvY2FsU3RvcmFnZScgfCAnc2Vzc2lvblN0b3JhZ2UnKTogdm9pZCB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yYWdlID0gc3RvcmFnZVR5cGUgPT09ICdsb2NhbFN0b3JhZ2UnID8gbG9jYWxTdG9yYWdlIDogc2Vzc2lvblN0b3JhZ2VcclxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHN0b3JhZ2UpXHJcbiAgICAgIFxyXG4gICAgICAvLyBSZW1vdmUgb2xkZXN0IGl0ZW1zIChzaW1wbGUgc3RyYXRlZ3kgLSByZW1vdmUgZmlyc3QgaGFsZiBvZiBpdGVtcylcclxuICAgICAgY29uc3QgaXRlbXNUb1JlbW92ZSA9IE1hdGguY2VpbChrZXlzLmxlbmd0aCAvIDIpXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXNUb1JlbW92ZTsgaSsrKSB7XHJcbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleXNbaV0pXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICAvLyBJZ25vcmUgY2xlYW51cCBlcnJvcnNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGRhdGEgaXMgU0FJUyBhc3Nlc3NtZW50IHRoYXQgbmVlZHMgb3B0aW1pemF0aW9uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpc1NBSVNBc3Nlc3NtZW50RGF0YShrZXk6IHN0cmluZywgdmFsdWU6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKCdzZXNzaW9uLScpICYmIFxyXG4gICAgICAgICAgIHZhbHVlPy5zZWxlY3RlZEZvcm1hdCA9PT0gJ3NhaXMnICYmIFxyXG4gICAgICAgICAgIHZhbHVlPy5leHRlbmRlZFJlc3BvbnNlcz8ubGVuZ3RoID4gMFxyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBDaGVjayBpZiBrZXkgbWlnaHQgYmUgYSBTQUlTIHNlc3Npb25cclxuICAgKi9cclxuICBwcml2YXRlIG1pZ2h0QmVTQUlTU2Vzc2lvbihrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKCdzZXNzaW9uLScpXHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIEdldCBzdG9yYWdlIGhlYWx0aCBpbmNsdWRpbmcgU0FJUyBvcHRpbWl6YXRpb24gbWV0cmljc1xyXG4gICAqL1xyXG4gIGdldEV4dGVuZGVkSGVhbHRoKCk6IFN0b3JhZ2VIZWFsdGggJiB7IHNhaXNPcHRpbWl6YXRpb24/OiBhbnkgfSB7XHJcbiAgICBjb25zdCBiYXNlSGVhbHRoID0gdGhpcy5jaGVja1N0b3JhZ2VIZWFsdGgoKVxyXG4gICAgY29uc3Qgc2Fpc0hlYWx0aCA9IG9wdGltaXplZFN0b3JhZ2UuY2hlY2tTQUlTU3RvcmFnZUhlYWx0aCgpXHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLmJhc2VIZWFsdGgsXHJcbiAgICAgIHNhaXNPcHRpbWl6YXRpb246IHNhaXNIZWFsdGhcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gQ2xlYW51cCBtZXRob2QgZm9yIGNvbXBvbmVudCB1bm1vdW50aW5nXHJcbiAgZGVzdHJveSgpOiB2b2lkIHtcclxuICAgIHRoaXMubWVtb3J5U3RvcmFnZS5jbGVhcigpXHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBzdG9yYWdlU2VydmljZSA9IG5ldyBTdG9yYWdlU2VydmljZSgpXHJcbmV4cG9ydCBkZWZhdWx0IHN0b3JhZ2VTZXJ2aWNlIl0sIm5hbWVzIjpbIm9wdGltaXplZFN0b3JhZ2UiLCJTdG9yYWdlU2VydmljZSIsImNoZWNrU3RvcmFnZUhlYWx0aCIsImxvY2FsU3RvcmFnZSIsImlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwic2Vzc2lvblN0b3JhZ2UiLCJpc1Nlc3Npb25TdG9yYWdlQXZhaWxhYmxlIiwiZ2V0SXRlbSIsImtleSIsIm1pZ2h0QmVTQUlTU2Vzc2lvbiIsInNhaXNEYXRhIiwicmV0cmlldmVTQUlTQXNzZXNzbWVudCIsInN1Y2Nlc3MiLCJkYXRhIiwibGF5ZXIiLCJsb2NhbFJlc3VsdCIsImdldEZyb21Mb2NhbFN0b3JhZ2UiLCJzZXNzaW9uUmVzdWx0IiwiZ2V0RnJvbVNlc3Npb25TdG9yYWdlIiwibWVtb3J5UmVzdWx0IiwiZ2V0RnJvbU1lbW9yeSIsImVycm9yIiwic2V0SXRlbSIsInZhbHVlIiwiaXNTQUlTQXNzZXNzbWVudERhdGEiLCJvcHRpbWl6ZWQiLCJzdG9yZVNBSVNBc3Nlc3NtZW50Iiwic2F2ZWRUbyIsImxheWVycyIsIm9wdGltaXphdGlvbiIsInNlcmlhbGl6ZWRWYWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdWNjZXNzQ291bnQiLCJlcnJvcnMiLCJzZXRUb0xvY2FsU3RvcmFnZSIsInB1c2giLCJzZXRUb1Nlc3Npb25TdG9yYWdlIiwibWVtb3J5U3RvcmFnZSIsInNldCIsImxlbmd0aCIsInVuZGVmaW5lZCIsInJlbW92ZUl0ZW0iLCJjbGVhbnVwU0FJU0RhdGEiLCJkZWxldGUiLCJyZW1vdmVkRnJvbSIsImNsZWFyIiwiY2xlYXJlZExheWVycyIsInRlc3RLZXkiLCJpdGVtIiwicGFyc2UiLCJFcnJvciIsIm5hbWUiLCJnZXQiLCJjbGVhbnVwT2xkU3RvcmFnZUl0ZW1zIiwic3RvcmFnZVR5cGUiLCJzdG9yYWdlIiwia2V5cyIsIk9iamVjdCIsIml0ZW1zVG9SZW1vdmUiLCJNYXRoIiwiY2VpbCIsImkiLCJzdGFydHNXaXRoIiwic2VsZWN0ZWRGb3JtYXQiLCJleHRlbmRlZFJlc3BvbnNlcyIsImdldEV4dGVuZGVkSGVhbHRoIiwiYmFzZUhlYWx0aCIsInNhaXNIZWFsdGgiLCJjaGVja1NBSVNTdG9yYWdlSGVhbHRoIiwic2Fpc09wdGltaXphdGlvbiIsImRlc3Ryb3kiLCJNYXAiLCJzdG9yYWdlU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/StorageService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/stores/assessment-store.ts":
/*!********************************************!*\
  !*** ./src/lib/stores/assessment-store.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAppStore: function() { return /* binding */ useAppStore; },\n/* harmony export */   useAssessmentStore: function() { return /* binding */ useAssessmentStore; },\n/* harmony export */   useUIStore: function() { return /* binding */ useUIStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var _lib_services_StorageService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/services/StorageService */ \"(app-pages-browser)/./src/lib/services/StorageService.ts\");\n/* harmony import */ var _lib_services_SessionService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/services/SessionService */ \"(app-pages-browser)/./src/lib/services/SessionService.ts\");\n/* harmony import */ var _lib_constants_assessment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/constants/assessment */ \"(app-pages-browser)/./src/lib/constants/assessment.ts\");\n\n\n\n\n\nconst initialAssessmentState = {\n    sessionId: \"\",\n    currentStep: \"welcome\",\n    language: \"en\",\n    responses: [],\n    coreResponses: [],\n    extendedResponses: [],\n    selectedFormat: null,\n    progress: 0,\n    isComplete: false\n};\nconst initialUIState = {\n    theme: \"light\",\n    direction: \"ltr\",\n    sidebarOpen: false,\n    currentPage: \"home\"\n};\nconst useAppStore = (0,zustand__WEBPACK_IMPORTED_MODULE_3__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_4__.devtools)((set, get)=>({\n        assessment: initialAssessmentState,\n        ui: initialUIState,\n        // Assessment actions\n        setSessionId: (sessionId)=>{\n            // Initialize session with SessionService\n            _lib_services_SessionService__WEBPACK_IMPORTED_MODULE_1__.SessionService.initializeSession(sessionId, \"core\");\n            set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        sessionId\n                    }\n                }));\n        },\n        setCurrentStep: (currentStep)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        currentStep\n                    }\n                })),\n        setLanguage: (language)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        language\n                    },\n                    ui: {\n                        ...state.ui,\n                        direction: language === \"ar\" ? \"rtl\" : \"ltr\"\n                    }\n                })),\n        addResponse: (response)=>set((state)=>{\n                // Check if response already exists for this question\n                const existingIndex = state.assessment.responses.findIndex((r)=>r.questionId === response.questionId);\n                let newResponses;\n                if (existingIndex >= 0) {\n                    // Replace existing response\n                    newResponses = [\n                        ...state.assessment.responses\n                    ];\n                    newResponses[existingIndex] = response;\n                } else {\n                    // Add new response\n                    newResponses = [\n                        ...state.assessment.responses,\n                        response\n                    ];\n                }\n                // Also update core/extended responses based on type\n                let newCoreResponses = [\n                    ...state.assessment.coreResponses\n                ];\n                let newExtendedResponses = [\n                    ...state.assessment.extendedResponses\n                ];\n                if (response.questionType === \"core\") {\n                    const coreIndex = newCoreResponses.findIndex((r)=>r.questionId === response.questionId);\n                    if (coreIndex >= 0) {\n                        newCoreResponses[coreIndex] = response;\n                    } else {\n                        newCoreResponses.push(response);\n                    }\n                } else {\n                    const extendedIndex = newExtendedResponses.findIndex((r)=>r.questionId === response.questionId);\n                    if (extendedIndex >= 0) {\n                        newExtendedResponses[extendedIndex] = response;\n                    } else {\n                        newExtendedResponses.push(response);\n                    }\n                }\n                const updatedAssessment = {\n                    ...state.assessment,\n                    responses: newResponses,\n                    coreResponses: newCoreResponses,\n                    extendedResponses: newExtendedResponses\n                };\n                // Auto-persist after each response\n                setTimeout(()=>{\n                    get().persistState();\n                }, 0);\n                return {\n                    assessment: updatedAssessment\n                };\n            }),\n        setResponses: (responses)=>set((state)=>{\n                // Separate core and extended responses\n                const coreResponses = responses.filter((r)=>r.questionType === \"core\");\n                const extendedResponses = responses.filter((r)=>r.questionType === \"extended\");\n                return {\n                    assessment: {\n                        ...state.assessment,\n                        responses,\n                        coreResponses,\n                        extendedResponses\n                    }\n                };\n            }),\n        setCoreResponses: (coreResponses)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        coreResponses\n                    }\n                })),\n        setExtendedResponses: (extendedResponses)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        extendedResponses\n                    }\n                })),\n        setSelectedFormat: (selectedFormat)=>{\n            const state = get();\n            // Transition to extended phase when format is selected\n            if (state.assessment.sessionId) {\n                _lib_services_SessionService__WEBPACK_IMPORTED_MODULE_1__.SessionService.transitionToExtendedPhase(state.assessment.sessionId);\n            }\n            // Initialize format-specific progress tracking\n            const formatProgress = {\n                totalQuestions: _lib_constants_assessment__WEBPACK_IMPORTED_MODULE_2__.TOTAL_QUESTIONS[selectedFormat],\n                currentQuestionIndex: 0,\n                completedQuestions: _lib_constants_assessment__WEBPACK_IMPORTED_MODULE_2__.CORE_QUESTIONS_COUNT,\n                questionPool: _lib_constants_assessment__WEBPACK_IMPORTED_MODULE_2__.QUESTION_POOLS[selectedFormat]\n            };\n            set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        selectedFormat,\n                        formatProgress,\n                        progress: _lib_constants_assessment__WEBPACK_IMPORTED_MODULE_2__.PROGRESS_MILESTONES.formatSelected // Set to 40% after format selection\n                    }\n                }));\n        },\n        updateProgress: (progress)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        progress\n                    }\n                })),\n        setProgress: (progress)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        progress\n                    }\n                })),\n        calculateFormatSpecificProgress: ()=>{\n            const state = get();\n            const { selectedFormat, formatProgress, coreResponses, extendedResponses } = state.assessment;\n            if (!selectedFormat || !formatProgress) {\n                // Core assessment progress only\n                return coreResponses.length / _lib_constants_assessment__WEBPACK_IMPORTED_MODULE_2__.CORE_QUESTIONS_COUNT * _lib_constants_assessment__WEBPACK_IMPORTED_MODULE_2__.PROGRESS_MILESTONES.coreComplete;\n            }\n            // Calculate total completed questions (core + extended)\n            const totalCompleted = coreResponses.length + extendedResponses.length;\n            const totalQuestions = formatProgress.totalQuestions;\n            // Calculate percentage (0-100)\n            return Math.min(100, Math.round(totalCompleted / totalQuestions * 100));\n        },\n        updateFormatProgress: (currentIndex)=>{\n            const state = get();\n            const { formatProgress } = state.assessment;\n            if (!formatProgress) return;\n            const updatedFormatProgress = {\n                ...formatProgress,\n                currentQuestionIndex: currentIndex,\n                completedQuestions: _lib_constants_assessment__WEBPACK_IMPORTED_MODULE_2__.CORE_QUESTIONS_COUNT + currentIndex\n            };\n            // Calculate and update progress automatically\n            const newProgress = get().calculateFormatSpecificProgress();\n            set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        formatProgress: updatedFormatProgress,\n                        progress: newProgress\n                    }\n                }));\n        },\n        completeAssessment: ()=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        isComplete: true,\n                        currentStep: \"results\"\n                    }\n                })),\n        resetAssessment: ()=>set((state)=>({\n                    assessment: {\n                        ...initialAssessmentState,\n                        language: state.assessment.language\n                    }\n                })),\n        setInterimResults: (interimResults)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        interimResults\n                    }\n                })),\n        setResults: (results)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        results\n                    }\n                })),\n        setStartTime: (startTime)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        startTime\n                    }\n                })),\n        setCompletionTime: (completionTime)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        completionTime\n                    }\n                })),\n        setCalculatedType: (calculatedType)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        calculatedType\n                    }\n                })),\n        setConfidence: (confidence)=>set((state)=>({\n                    assessment: {\n                        ...state.assessment,\n                        confidence\n                    }\n                })),\n        persistState: ()=>{\n            const state = get();\n            const sessionData = {\n                sessionId: state.assessment.sessionId,\n                language: state.assessment.language,\n                currentStep: state.assessment.currentStep,\n                startTime: state.assessment.startTime || new Date(),\n                completionTime: state.assessment.completionTime,\n                selectedFormat: state.assessment.selectedFormat,\n                coreResponses: state.assessment.coreResponses,\n                extendedResponses: state.assessment.extendedResponses,\n                calculatedType: state.assessment.calculatedType,\n                confidence: state.assessment.confidence,\n                progress: state.assessment.progress,\n                isComplete: state.assessment.isComplete,\n                formatProgress: state.assessment.formatProgress\n            };\n            // Update session activity when persisting state\n            _lib_services_SessionService__WEBPACK_IMPORTED_MODULE_1__.SessionService.updateActivity();\n            _lib_services_StorageService__WEBPACK_IMPORTED_MODULE_0__.storageService.setItem(state.assessment.sessionId, sessionData);\n        },\n        restoreFromSession: (sessionId)=>{\n            try {\n                const result = _lib_services_StorageService__WEBPACK_IMPORTED_MODULE_0__.storageService.getItem(sessionId);\n                if (result.success && result.data) {\n                    const sessionData = result.data;\n                    set((state)=>({\n                            assessment: {\n                                ...state.assessment,\n                                sessionId: sessionData.sessionId,\n                                language: sessionData.language,\n                                currentStep: sessionData.currentStep,\n                                startTime: sessionData.startTime ? new Date(sessionData.startTime) : undefined,\n                                completionTime: sessionData.completionTime ? new Date(sessionData.completionTime) : undefined,\n                                selectedFormat: sessionData.selectedFormat,\n                                coreResponses: sessionData.coreResponses || [],\n                                extendedResponses: sessionData.extendedResponses || [],\n                                responses: [\n                                    ...sessionData.coreResponses || [],\n                                    ...sessionData.extendedResponses || []\n                                ],\n                                calculatedType: sessionData.calculatedType,\n                                confidence: sessionData.confidence,\n                                progress: sessionData.progress,\n                                isComplete: sessionData.isComplete,\n                                formatProgress: sessionData.formatProgress\n                            },\n                            ui: {\n                                ...state.ui,\n                                direction: sessionData.language === \"ar\" ? \"rtl\" : \"ltr\"\n                            }\n                        }));\n                    return true;\n                }\n                return false;\n            } catch (error) {\n                console.error(\"Failed to restore session:\", error);\n                return false;\n            }\n        },\n        // UI actions\n        setTheme: (theme)=>set((state)=>({\n                    ui: {\n                        ...state.ui,\n                        theme\n                    }\n                })),\n        setDirection: (direction)=>set((state)=>({\n                    ui: {\n                        ...state.ui,\n                        direction\n                    }\n                })),\n        toggleSidebar: ()=>set((state)=>({\n                    ui: {\n                        ...state.ui,\n                        sidebarOpen: !state.ui.sidebarOpen\n                    }\n                })),\n        setCurrentPage: (currentPage)=>set((state)=>({\n                    ui: {\n                        ...state.ui,\n                        currentPage\n                    }\n                }))\n    }), {\n    name: \"MBTI App Store\"\n}));\n// Selector hooks for better performance\nconst useAssessmentStore = ()=>useAppStore((state)=>({\n            sessionId: state.assessment.sessionId,\n            currentStep: state.assessment.currentStep,\n            language: state.assessment.language,\n            responses: state.assessment.responses,\n            coreResponses: state.assessment.coreResponses,\n            extendedResponses: state.assessment.extendedResponses,\n            selectedFormat: state.assessment.selectedFormat,\n            progress: state.assessment.progress,\n            isComplete: state.assessment.isComplete,\n            startTime: state.assessment.startTime,\n            completionTime: state.assessment.completionTime,\n            calculatedType: state.assessment.calculatedType,\n            confidence: state.assessment.confidence,\n            interimResults: state.assessment.interimResults,\n            formatProgress: state.assessment.formatProgress,\n            results: state.assessment.results,\n            setSessionId: state.setSessionId,\n            setCurrentStep: state.setCurrentStep,\n            setLanguage: state.setLanguage,\n            addResponse: state.addResponse,\n            setResponses: state.setResponses,\n            setCoreResponses: state.setCoreResponses,\n            setExtendedResponses: state.setExtendedResponses,\n            setSelectedFormat: state.setSelectedFormat,\n            updateProgress: state.updateProgress,\n            setProgress: state.setProgress,\n            calculateFormatSpecificProgress: state.calculateFormatSpecificProgress,\n            updateFormatProgress: state.updateFormatProgress,\n            completeAssessment: state.completeAssessment,\n            resetAssessment: state.resetAssessment,\n            setInterimResults: state.setInterimResults,\n            setResults: state.setResults,\n            setStartTime: state.setStartTime,\n            setCompletionTime: state.setCompletionTime,\n            setCalculatedType: state.setCalculatedType,\n            setConfidence: state.setConfidence,\n            persistState: state.persistState,\n            restoreFromSession: state.restoreFromSession\n        }));\nconst useUIStore = ()=>useAppStore((state)=>({\n            theme: state.ui.theme,\n            direction: state.ui.direction,\n            sidebarOpen: state.ui.sidebarOpen,\n            currentPage: state.ui.currentPage,\n            setTheme: state.setTheme,\n            setDirection: state.setDirection,\n            toggleSidebar: state.toggleSidebar,\n            setCurrentPage: state.setCurrentPage\n        }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3RvcmVzL2Fzc2Vzc21lbnQtc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDYTtBQUVpQjtBQUNBO0FBQzJFO0FBdUZ6SSxNQUFNUSx5QkFBMEM7SUFDOUNDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxVQUFVO0lBQ1ZDLFdBQVcsRUFBRTtJQUNiQyxlQUFlLEVBQUU7SUFDakJDLG1CQUFtQixFQUFFO0lBQ3JCQyxnQkFBZ0I7SUFDaEJDLFVBQVU7SUFDVkMsWUFBWTtBQUNkO0FBRUEsTUFBTUMsaUJBQTBCO0lBQzlCQyxPQUFPO0lBQ1BDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxhQUFhO0FBQ2Y7QUFFTyxNQUFNQyxjQUFjdkIsK0NBQU1BLEdBQy9CQyw0REFBUUEsQ0FDSixDQUFDdUIsS0FBS0MsTUFBUztRQUNiQyxZQUFZbEI7UUFDWm1CLElBQUlUO1FBRUoscUJBQXFCO1FBQ3JCVSxjQUFjLENBQUNuQjtZQUNiLHlDQUF5QztZQUN6Q04sd0VBQWNBLENBQUMwQixpQkFBaUIsQ0FBQ3BCLFdBQVc7WUFFNUNlLElBQUksQ0FBQ00sUUFBVztvQkFDZEosWUFBWTt3QkFBRSxHQUFHSSxNQUFNSixVQUFVO3dCQUFFakI7b0JBQVU7Z0JBQy9DO1FBQ0Y7UUFFQXNCLGdCQUFnQixDQUFDckIsY0FDZmMsSUFBSSxDQUFDTSxRQUFXO29CQUNkSixZQUFZO3dCQUFFLEdBQUdJLE1BQU1KLFVBQVU7d0JBQUVoQjtvQkFBWTtnQkFDakQ7UUFFRnNCLGFBQWEsQ0FBQ3JCLFdBQ1phLElBQUksQ0FBQ00sUUFBVztvQkFDZEosWUFBWTt3QkFBRSxHQUFHSSxNQUFNSixVQUFVO3dCQUFFZjtvQkFBUztvQkFDNUNnQixJQUFJO3dCQUFFLEdBQUdHLE1BQU1ILEVBQUU7d0JBQUVQLFdBQVdULGFBQWEsT0FBTyxRQUFRO29CQUFNO2dCQUNsRTtRQUVGc0IsYUFBYSxDQUFDQyxXQUNaVixJQUFJLENBQUNN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TUFBTUgsRUFBRSxDQUFDUCxTQUFTO1lBQzdCQyxhQUFhUyxNQUFNSCxFQUFFLENBQUNOLFdBQVc7WUFDakNDLGFBQWFRLE1BQU1ILEVBQUUsQ0FBQ0wsV0FBVztZQUNqQzhFLFVBQVV0RSxNQUFNc0UsUUFBUTtZQUN4QkMsY0FBY3ZFLE1BQU11RSxZQUFZO1lBQ2hDQyxlQUFleEUsTUFBTXdFLGFBQWE7WUFDbENDLGdCQUFnQnpFLE1BQU15RSxjQUFjO1FBQ3RDLElBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zdG9yZXMvYXNzZXNzbWVudC1zdG9yZS50cz84ZjdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnXHJcbmltcG9ydCB7IGRldnRvb2xzIH0gZnJvbSAnenVzdGFuZC9taWRkbGV3YXJlJ1xyXG5pbXBvcnQgeyBRdWVzdGlvblJlc3BvbnNlIH0gZnJvbSAnQC9saWIvdHlwZXMnXHJcbmltcG9ydCB7IHN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvU3RvcmFnZVNlcnZpY2UnXHJcbmltcG9ydCB7IFNlc3Npb25TZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvU2Vzc2lvblNlcnZpY2UnXHJcbmltcG9ydCB7IENPUkVfUVVFU1RJT05TX0NPVU5ULCBGT1JNQVRfUVVFU1RJT05TLCBUT1RBTF9RVUVTVElPTlMsIFFVRVNUSU9OX1BPT0xTLCBQUk9HUkVTU19NSUxFU1RPTkVTIH0gZnJvbSAnQC9saWIvY29uc3RhbnRzL2Fzc2Vzc21lbnQnXHJcblxyXG5leHBvcnQgdHlwZSBBc3Nlc3NtZW50U3RlcCA9ICd3ZWxjb21lJyB8ICdjb3JlLXF1ZXN0aW9ucycgfCAnaW50ZXJpbS1yZXN1bHRzJyB8ICdmb3JtYXQtc2VsZWN0aW9uJyB8ICdxdWVzdGlvbnMnIHwgJ3Jlc3VsdHMnIHwgJ2NvYWNoaW5nJ1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBc3Nlc3NtZW50U3RhdGUge1xyXG4gIHNlc3Npb25JZDogc3RyaW5nXHJcbiAgY3VycmVudFN0ZXA6IEFzc2Vzc21lbnRTdGVwXHJcbiAgbGFuZ3VhZ2U6ICdlbicgfCAnYXInXHJcbiAgcmVzcG9uc2VzOiBRdWVzdGlvblJlc3BvbnNlW11cclxuICBjb3JlUmVzcG9uc2VzOiBRdWVzdGlvblJlc3BvbnNlW11cclxuICBleHRlbmRlZFJlc3BvbnNlczogUXVlc3Rpb25SZXNwb25zZVtdXHJcbiAgc2VsZWN0ZWRGb3JtYXQ6ICdzY2VuYXJpb3MnIHwgJ3RyYWl0cycgfCAnc2FpcycgfCBudWxsXHJcbiAgcHJvZ3Jlc3M6IG51bWJlclxyXG4gIGlzQ29tcGxldGU6IGJvb2xlYW5cclxuICBzdGFydFRpbWU/OiBEYXRlXHJcbiAgY29tcGxldGlvblRpbWU/OiBEYXRlXHJcbiAgY2FsY3VsYXRlZFR5cGU/OiBzdHJpbmdcclxuICBjb25maWRlbmNlPzogbnVtYmVyXHJcbiAgaW50ZXJpbVJlc3VsdHM/OiB7XHJcbiAgICBtYnRpVHlwZTogc3RyaW5nXHJcbiAgICBjb25maWRlbmNlOiBudW1iZXJcclxuICAgIGluc2lnaHRzOiBzdHJpbmdbXVxyXG4gICAgZGlzY2xhaW1lcjogc3RyaW5nXHJcbiAgfVxyXG4gIC8vIEZvcm1hdC1zcGVjaWZpYyB0cmFja2luZ1xyXG4gIGZvcm1hdFByb2dyZXNzPzoge1xyXG4gICAgdG90YWxRdWVzdGlvbnM6IG51bWJlclxyXG4gICAgY3VycmVudFF1ZXN0aW9uSW5kZXg6IG51bWJlclxyXG4gICAgY29tcGxldGVkUXVlc3Rpb25zOiBudW1iZXJcclxuICAgIHF1ZXN0aW9uUG9vbDogc3RyaW5nXHJcbiAgfVxyXG4gIC8vIEZpbmFsIGNhbGN1bGF0aW9uIHJlc3VsdHNcclxuICByZXN1bHRzPzoge1xyXG4gICAgbWJ0aVR5cGU6IHN0cmluZ1xyXG4gICAgc2NvcmVzOiB7XHJcbiAgICAgICdFL0knOiBudW1iZXJcclxuICAgICAgJ1MvTic6IG51bWJlclxyXG4gICAgICAnVC9GJzogbnVtYmVyXHJcbiAgICAgICdKL1AnOiBudW1iZXJcclxuICAgIH1cclxuICAgIGNvbmZpZGVuY2U6IG51bWJlclxyXG4gICAgbWV0aG9kb2xvZ3k6IHN0cmluZ1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVSVN0YXRlIHtcclxuICB0aGVtZTogJ2xpZ2h0JyB8ICdkYXJrJ1xyXG4gIGRpcmVjdGlvbjogJ2x0cicgfCAncnRsJ1xyXG4gIHNpZGViYXJPcGVuOiBib29sZWFuXHJcbiAgY3VycmVudFBhZ2U6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFwcFN0b3JlIHtcclxuICBhc3Nlc3NtZW50OiBBc3Nlc3NtZW50U3RhdGVcclxuICB1aTogVUlTdGF0ZVxyXG4gIFxyXG4gIC8vIEFzc2Vzc21lbnQgYWN0aW9uc1xyXG4gIHNldFNlc3Npb25JZDogKHNlc3Npb25JZDogc3RyaW5nKSA9PiB2b2lkXHJcbiAgc2V0Q3VycmVudFN0ZXA6IChzdGVwOiBBc3Nlc3NtZW50U3RlcCkgPT4gdm9pZFxyXG4gIHNldExhbmd1YWdlOiAobGFuZ3VhZ2U6ICdlbicgfCAnYXInKSA9PiB2b2lkXHJcbiAgYWRkUmVzcG9uc2U6IChyZXNwb25zZTogUXVlc3Rpb25SZXNwb25zZSkgPT4gdm9pZFxyXG4gIHNldFJlc3BvbnNlczogKHJlc3BvbnNlczogUXVlc3Rpb25SZXNwb25zZVtdKSA9PiB2b2lkXHJcbiAgc2V0Q29yZVJlc3BvbnNlczogKHJlc3BvbnNlczogUXVlc3Rpb25SZXNwb25zZVtdKSA9PiB2b2lkXHJcbiAgc2V0RXh0ZW5kZWRSZXNwb25zZXM6IChyZXNwb25zZXM6IFF1ZXN0aW9uUmVzcG9uc2VbXSkgPT4gdm9pZFxyXG4gIHNldFNlbGVjdGVkRm9ybWF0OiAoZm9ybWF0OiAnc2NlbmFyaW9zJyB8ICd0cmFpdHMnIHwgJ3NhaXMnKSA9PiB2b2lkXHJcbiAgdXBkYXRlUHJvZ3Jlc3M6IChwcm9ncmVzczogbnVtYmVyKSA9PiB2b2lkXHJcbiAgc2V0UHJvZ3Jlc3M6IChwcm9ncmVzczogbnVtYmVyKSA9PiB2b2lkXHJcbiAgY2FsY3VsYXRlRm9ybWF0U3BlY2lmaWNQcm9ncmVzczogKCkgPT4gbnVtYmVyXHJcbiAgdXBkYXRlRm9ybWF0UHJvZ3Jlc3M6IChjdXJyZW50SW5kZXg6IG51bWJlcikgPT4gdm9pZFxyXG4gIGNvbXBsZXRlQXNzZXNzbWVudDogKCkgPT4gdm9pZFxyXG4gIHJlc2V0QXNzZXNzbWVudDogKCkgPT4gdm9pZFxyXG4gIHNldEludGVyaW1SZXN1bHRzOiAocmVzdWx0czogQXNzZXNzbWVudFN0YXRlWydpbnRlcmltUmVzdWx0cyddKSA9PiB2b2lkXHJcbiAgc2V0UmVzdWx0czogKHJlc3VsdHM6IEFzc2Vzc21lbnRTdGF0ZVsncmVzdWx0cyddKSA9PiB2b2lkXHJcbiAgc2V0U3RhcnRUaW1lOiAodGltZTogRGF0ZSkgPT4gdm9pZFxyXG4gIHNldENvbXBsZXRpb25UaW1lOiAodGltZTogRGF0ZSkgPT4gdm9pZFxyXG4gIHNldENhbGN1bGF0ZWRUeXBlOiAodHlwZTogc3RyaW5nKSA9PiB2b2lkXHJcbiAgc2V0Q29uZmlkZW5jZTogKGNvbmZpZGVuY2U6IG51bWJlcikgPT4gdm9pZFxyXG4gIHBlcnNpc3RTdGF0ZTogKCkgPT4gdm9pZFxyXG4gIHJlc3RvcmVGcm9tU2Vzc2lvbjogKHNlc3Npb25JZDogc3RyaW5nKSA9PiBib29sZWFuXHJcbiAgXHJcbiAgLy8gVUkgYWN0aW9uc1xyXG4gIHNldFRoZW1lOiAodGhlbWU6ICdsaWdodCcgfCAnZGFyaycpID0+IHZvaWRcclxuICBzZXREaXJlY3Rpb246IChkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcpID0+IHZvaWRcclxuICB0b2dnbGVTaWRlYmFyOiAoKSA9PiB2b2lkXHJcbiAgc2V0Q3VycmVudFBhZ2U6IChwYWdlOiBzdHJpbmcpID0+IHZvaWRcclxufVxyXG5cclxuY29uc3QgaW5pdGlhbEFzc2Vzc21lbnRTdGF0ZTogQXNzZXNzbWVudFN0YXRlID0ge1xyXG4gIHNlc3Npb25JZDogJycsXHJcbiAgY3VycmVudFN0ZXA6ICd3ZWxjb21lJyxcclxuICBsYW5ndWFnZTogJ2VuJyxcclxuICByZXNwb25zZXM6IFtdLFxyXG4gIGNvcmVSZXNwb25zZXM6IFtdLFxyXG4gIGV4dGVuZGVkUmVzcG9uc2VzOiBbXSxcclxuICBzZWxlY3RlZEZvcm1hdDogbnVsbCxcclxuICBwcm9ncmVzczogMCxcclxuICBpc0NvbXBsZXRlOiBmYWxzZSxcclxufVxyXG5cclxuY29uc3QgaW5pdGlhbFVJU3RhdGU6IFVJU3RhdGUgPSB7XHJcbiAgdGhlbWU6ICdsaWdodCcsXHJcbiAgZGlyZWN0aW9uOiAnbHRyJyxcclxuICBzaWRlYmFyT3BlbjogZmFsc2UsXHJcbiAgY3VycmVudFBhZ2U6ICdob21lJyxcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUFwcFN0b3JlID0gY3JlYXRlPEFwcFN0b3JlPigpKFxyXG4gIGRldnRvb2xzKFxyXG4gICAgICAoc2V0LCBnZXQpID0+ICh7XHJcbiAgICAgICAgYXNzZXNzbWVudDogaW5pdGlhbEFzc2Vzc21lbnRTdGF0ZSxcclxuICAgICAgICB1aTogaW5pdGlhbFVJU3RhdGUsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQXNzZXNzbWVudCBhY3Rpb25zXHJcbiAgICAgICAgc2V0U2Vzc2lvbklkOiAoc2Vzc2lvbklkKSA9PiB7XHJcbiAgICAgICAgICAvLyBJbml0aWFsaXplIHNlc3Npb24gd2l0aCBTZXNzaW9uU2VydmljZVxyXG4gICAgICAgICAgU2Vzc2lvblNlcnZpY2UuaW5pdGlhbGl6ZVNlc3Npb24oc2Vzc2lvbklkLCAnY29yZScpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgICAgICBhc3Nlc3NtZW50OiB7IC4uLnN0YXRlLmFzc2Vzc21lbnQsIHNlc3Npb25JZCB9XHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAgIFxyXG4gICAgICAgIHNldEN1cnJlbnRTdGVwOiAoY3VycmVudFN0ZXApID0+XHJcbiAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgICAgICBhc3Nlc3NtZW50OiB7IC4uLnN0YXRlLmFzc2Vzc21lbnQsIGN1cnJlbnRTdGVwIH1cclxuICAgICAgICAgIH0pKSxcclxuICAgICAgICAgIFxyXG4gICAgICAgIHNldExhbmd1YWdlOiAobGFuZ3VhZ2UpID0+XHJcbiAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgICAgICBhc3Nlc3NtZW50OiB7IC4uLnN0YXRlLmFzc2Vzc21lbnQsIGxhbmd1YWdlIH0sXHJcbiAgICAgICAgICAgIHVpOiB7IC4uLnN0YXRlLnVpLCBkaXJlY3Rpb246IGxhbmd1YWdlID09PSAnYXInID8gJ3J0bCcgOiAnbHRyJyB9XHJcbiAgICAgICAgICB9KSksXHJcbiAgICAgICAgICBcclxuICAgICAgICBhZGRSZXNwb25zZTogKHJlc3BvbnNlKSA9PlxyXG4gICAgICAgICAgc2V0KChzdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiByZXNwb25zZSBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBxdWVzdGlvblxyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gc3RhdGUuYXNzZXNzbWVudC5yZXNwb25zZXMuZmluZEluZGV4KFxyXG4gICAgICAgICAgICAgIHIgPT4gci5xdWVzdGlvbklkID09PSByZXNwb25zZS5xdWVzdGlvbklkXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBuZXdSZXNwb25zZXNcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgIC8vIFJlcGxhY2UgZXhpc3RpbmcgcmVzcG9uc2VcclxuICAgICAgICAgICAgICBuZXdSZXNwb25zZXMgPSBbLi4uc3RhdGUuYXNzZXNzbWVudC5yZXNwb25zZXNdXHJcbiAgICAgICAgICAgICAgbmV3UmVzcG9uc2VzW2V4aXN0aW5nSW5kZXhdID0gcmVzcG9uc2VcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBBZGQgbmV3IHJlc3BvbnNlXHJcbiAgICAgICAgICAgICAgbmV3UmVzcG9uc2VzID0gWy4uLnN0YXRlLmFzc2Vzc21lbnQucmVzcG9uc2VzLCByZXNwb25zZV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQWxzbyB1cGRhdGUgY29yZS9leHRlbmRlZCByZXNwb25zZXMgYmFzZWQgb24gdHlwZVxyXG4gICAgICAgICAgICBsZXQgbmV3Q29yZVJlc3BvbnNlcyA9IFsuLi5zdGF0ZS5hc3Nlc3NtZW50LmNvcmVSZXNwb25zZXNdXHJcbiAgICAgICAgICAgIGxldCBuZXdFeHRlbmRlZFJlc3BvbnNlcyA9IFsuLi5zdGF0ZS5hc3Nlc3NtZW50LmV4dGVuZGVkUmVzcG9uc2VzXVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnF1ZXN0aW9uVHlwZSA9PT0gJ2NvcmUnKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29yZUluZGV4ID0gbmV3Q29yZVJlc3BvbnNlcy5maW5kSW5kZXgociA9PiByLnF1ZXN0aW9uSWQgPT09IHJlc3BvbnNlLnF1ZXN0aW9uSWQpXHJcbiAgICAgICAgICAgICAgaWYgKGNvcmVJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDb3JlUmVzcG9uc2VzW2NvcmVJbmRleF0gPSByZXNwb25zZVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDb3JlUmVzcG9uc2VzLnB1c2gocmVzcG9uc2UpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGV4dGVuZGVkSW5kZXggPSBuZXdFeHRlbmRlZFJlc3BvbnNlcy5maW5kSW5kZXgociA9PiByLnF1ZXN0aW9uSWQgPT09IHJlc3BvbnNlLnF1ZXN0aW9uSWQpXHJcbiAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgbmV3RXh0ZW5kZWRSZXNwb25zZXNbZXh0ZW5kZWRJbmRleF0gPSByZXNwb25zZVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFeHRlbmRlZFJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEFzc2Vzc21lbnQgPSB7XHJcbiAgICAgICAgICAgICAgLi4uc3RhdGUuYXNzZXNzbWVudCxcclxuICAgICAgICAgICAgICByZXNwb25zZXM6IG5ld1Jlc3BvbnNlcyxcclxuICAgICAgICAgICAgICBjb3JlUmVzcG9uc2VzOiBuZXdDb3JlUmVzcG9uc2VzLFxyXG4gICAgICAgICAgICAgIGV4dGVuZGVkUmVzcG9uc2VzOiBuZXdFeHRlbmRlZFJlc3BvbnNlc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBdXRvLXBlcnNpc3QgYWZ0ZXIgZWFjaCByZXNwb25zZVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICBnZXQoKS5wZXJzaXN0U3RhdGUoKVxyXG4gICAgICAgICAgICB9LCAwKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBhc3Nlc3NtZW50OiB1cGRhdGVkQXNzZXNzbWVudFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIFxyXG4gICAgICAgIHNldFJlc3BvbnNlczogKHJlc3BvbnNlcykgPT5cclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+IHtcclxuICAgICAgICAgICAgLy8gU2VwYXJhdGUgY29yZSBhbmQgZXh0ZW5kZWQgcmVzcG9uc2VzXHJcbiAgICAgICAgICAgIGNvbnN0IGNvcmVSZXNwb25zZXMgPSByZXNwb25zZXMuZmlsdGVyKHIgPT4gci5xdWVzdGlvblR5cGUgPT09ICdjb3JlJylcclxuICAgICAgICAgICAgY29uc3QgZXh0ZW5kZWRSZXNwb25zZXMgPSByZXNwb25zZXMuZmlsdGVyKHIgPT4gci5xdWVzdGlvblR5cGUgPT09ICdleHRlbmRlZCcpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHsgXHJcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZS5hc3Nlc3NtZW50LCBcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlcywgXHJcbiAgICAgICAgICAgICAgICBjb3JlUmVzcG9uc2VzLCBcclxuICAgICAgICAgICAgICAgIGV4dGVuZGVkUmVzcG9uc2VzIFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSksXHJcblxyXG4gICAgICAgIHNldENvcmVSZXNwb25zZXM6IChjb3JlUmVzcG9uc2VzKSA9PlxyXG4gICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICAgICAgYXNzZXNzbWVudDogeyAuLi5zdGF0ZS5hc3Nlc3NtZW50LCBjb3JlUmVzcG9uc2VzIH1cclxuICAgICAgICAgIH0pKSxcclxuXHJcbiAgICAgICAgc2V0RXh0ZW5kZWRSZXNwb25zZXM6IChleHRlbmRlZFJlc3BvbnNlcykgPT5cclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHsgLi4uc3RhdGUuYXNzZXNzbWVudCwgZXh0ZW5kZWRSZXNwb25zZXMgfVxyXG4gICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgc2V0U2VsZWN0ZWRGb3JtYXQ6IChzZWxlY3RlZEZvcm1hdCkgPT4ge1xyXG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVHJhbnNpdGlvbiB0byBleHRlbmRlZCBwaGFzZSB3aGVuIGZvcm1hdCBpcyBzZWxlY3RlZFxyXG4gICAgICAgICAgaWYgKHN0YXRlLmFzc2Vzc21lbnQuc2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgIFNlc3Npb25TZXJ2aWNlLnRyYW5zaXRpb25Ub0V4dGVuZGVkUGhhc2Uoc3RhdGUuYXNzZXNzbWVudC5zZXNzaW9uSWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBJbml0aWFsaXplIGZvcm1hdC1zcGVjaWZpYyBwcm9ncmVzcyB0cmFja2luZ1xyXG4gICAgICAgICAgY29uc3QgZm9ybWF0UHJvZ3Jlc3MgPSB7XHJcbiAgICAgICAgICAgIHRvdGFsUXVlc3Rpb25zOiBUT1RBTF9RVUVTVElPTlNbc2VsZWN0ZWRGb3JtYXRdLFxyXG4gICAgICAgICAgICBjdXJyZW50UXVlc3Rpb25JbmRleDogMCxcclxuICAgICAgICAgICAgY29tcGxldGVkUXVlc3Rpb25zOiBDT1JFX1FVRVNUSU9OU19DT1VOVCwgLy8gQ29yZSBxdWVzdGlvbnMgYWxyZWFkeSBjb21wbGV0ZWRcclxuICAgICAgICAgICAgcXVlc3Rpb25Qb29sOiBRVUVTVElPTl9QT09MU1tzZWxlY3RlZEZvcm1hdF1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHsgXHJcbiAgICAgICAgICAgICAgLi4uc3RhdGUuYXNzZXNzbWVudCwgXHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWRGb3JtYXQsXHJcbiAgICAgICAgICAgICAgZm9ybWF0UHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgICAgcHJvZ3Jlc3M6IFBST0dSRVNTX01JTEVTVE9ORVMuZm9ybWF0U2VsZWN0ZWQgLy8gU2V0IHRvIDQwJSBhZnRlciBmb3JtYXQgc2VsZWN0aW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgdXBkYXRlUHJvZ3Jlc3M6IChwcm9ncmVzcykgPT5cclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHsgLi4uc3RhdGUuYXNzZXNzbWVudCwgcHJvZ3Jlc3MgfVxyXG4gICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgc2V0UHJvZ3Jlc3M6IChwcm9ncmVzcykgPT5cclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHsgLi4uc3RhdGUuYXNzZXNzbWVudCwgcHJvZ3Jlc3MgfVxyXG4gICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgY2FsY3VsYXRlRm9ybWF0U3BlY2lmaWNQcm9ncmVzczogKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcclxuICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRGb3JtYXQsIGZvcm1hdFByb2dyZXNzLCBjb3JlUmVzcG9uc2VzLCBleHRlbmRlZFJlc3BvbnNlcyB9ID0gc3RhdGUuYXNzZXNzbWVudDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKCFzZWxlY3RlZEZvcm1hdCB8fCAhZm9ybWF0UHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgLy8gQ29yZSBhc3Nlc3NtZW50IHByb2dyZXNzIG9ubHlcclxuICAgICAgICAgICAgcmV0dXJuIChjb3JlUmVzcG9uc2VzLmxlbmd0aCAvIENPUkVfUVVFU1RJT05TX0NPVU5UKSAqIFBST0dSRVNTX01JTEVTVE9ORVMuY29yZUNvbXBsZXRlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdG90YWwgY29tcGxldGVkIHF1ZXN0aW9ucyAoY29yZSArIGV4dGVuZGVkKVxyXG4gICAgICAgICAgY29uc3QgdG90YWxDb21wbGV0ZWQgPSBjb3JlUmVzcG9uc2VzLmxlbmd0aCArIGV4dGVuZGVkUmVzcG9uc2VzLmxlbmd0aDtcclxuICAgICAgICAgIGNvbnN0IHRvdGFsUXVlc3Rpb25zID0gZm9ybWF0UHJvZ3Jlc3MudG90YWxRdWVzdGlvbnM7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlICgwLTEwMClcclxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbigxMDAsIE1hdGgucm91bmQoKHRvdGFsQ29tcGxldGVkIC8gdG90YWxRdWVzdGlvbnMpICogMTAwKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICB1cGRhdGVGb3JtYXRQcm9ncmVzczogKGN1cnJlbnRJbmRleCkgPT4ge1xyXG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcclxuICAgICAgICAgIGNvbnN0IHsgZm9ybWF0UHJvZ3Jlc3MgfSA9IHN0YXRlLmFzc2Vzc21lbnQ7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmICghZm9ybWF0UHJvZ3Jlc3MpIHJldHVybjtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgdXBkYXRlZEZvcm1hdFByb2dyZXNzID0ge1xyXG4gICAgICAgICAgICAuLi5mb3JtYXRQcm9ncmVzcyxcclxuICAgICAgICAgICAgY3VycmVudFF1ZXN0aW9uSW5kZXg6IGN1cnJlbnRJbmRleCxcclxuICAgICAgICAgICAgY29tcGxldGVkUXVlc3Rpb25zOiBDT1JFX1FVRVNUSU9OU19DT1VOVCArIGN1cnJlbnRJbmRleFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIGFuZCB1cGRhdGUgcHJvZ3Jlc3MgYXV0b21hdGljYWxseVxyXG4gICAgICAgICAgY29uc3QgbmV3UHJvZ3Jlc3MgPSBnZXQoKS5jYWxjdWxhdGVGb3JtYXRTcGVjaWZpY1Byb2dyZXNzKCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHtcclxuICAgICAgICAgICAgICAuLi5zdGF0ZS5hc3Nlc3NtZW50LFxyXG4gICAgICAgICAgICAgIGZvcm1hdFByb2dyZXNzOiB1cGRhdGVkRm9ybWF0UHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgICAgcHJvZ3Jlc3M6IG5ld1Byb2dyZXNzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgY29tcGxldGVBc3Nlc3NtZW50OiAoKSA9PlxyXG4gICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICAgICAgYXNzZXNzbWVudDogeyAuLi5zdGF0ZS5hc3Nlc3NtZW50LCBpc0NvbXBsZXRlOiB0cnVlLCBjdXJyZW50U3RlcDogJ3Jlc3VsdHMnIH1cclxuICAgICAgICAgIH0pKSxcclxuICAgICAgICAgIFxyXG4gICAgICAgIHJlc2V0QXNzZXNzbWVudDogKCkgPT5cclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHsgLi4uaW5pdGlhbEFzc2Vzc21lbnRTdGF0ZSwgbGFuZ3VhZ2U6IHN0YXRlLmFzc2Vzc21lbnQubGFuZ3VhZ2UgfVxyXG4gICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgc2V0SW50ZXJpbVJlc3VsdHM6IChpbnRlcmltUmVzdWx0cykgPT5cclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHsgLi4uc3RhdGUuYXNzZXNzbWVudCwgaW50ZXJpbVJlc3VsdHMgfVxyXG4gICAgICAgICAgfSkpLFxyXG5cclxuICAgICAgICBzZXRSZXN1bHRzOiAocmVzdWx0cykgPT5cclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHsgLi4uc3RhdGUuYXNzZXNzbWVudCwgcmVzdWx0cyB9XHJcbiAgICAgICAgICB9KSksXHJcblxyXG4gICAgICAgIHNldFN0YXJ0VGltZTogKHN0YXJ0VGltZSkgPT5cclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHsgLi4uc3RhdGUuYXNzZXNzbWVudCwgc3RhcnRUaW1lIH1cclxuICAgICAgICAgIH0pKSxcclxuXHJcbiAgICAgICAgc2V0Q29tcGxldGlvblRpbWU6IChjb21wbGV0aW9uVGltZSkgPT5cclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHsgLi4uc3RhdGUuYXNzZXNzbWVudCwgY29tcGxldGlvblRpbWUgfVxyXG4gICAgICAgICAgfSkpLFxyXG5cclxuICAgICAgICBzZXRDYWxjdWxhdGVkVHlwZTogKGNhbGN1bGF0ZWRUeXBlKSA9PlxyXG4gICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICAgICAgYXNzZXNzbWVudDogeyAuLi5zdGF0ZS5hc3Nlc3NtZW50LCBjYWxjdWxhdGVkVHlwZSB9XHJcbiAgICAgICAgICB9KSksXHJcblxyXG4gICAgICAgIHNldENvbmZpZGVuY2U6IChjb25maWRlbmNlKSA9PlxyXG4gICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICAgICAgYXNzZXNzbWVudDogeyAuLi5zdGF0ZS5hc3Nlc3NtZW50LCBjb25maWRlbmNlIH1cclxuICAgICAgICAgIH0pKSxcclxuXHJcbiAgICAgICAgcGVyc2lzdFN0YXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpXHJcbiAgICAgICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHtcclxuICAgICAgICAgICAgc2Vzc2lvbklkOiBzdGF0ZS5hc3Nlc3NtZW50LnNlc3Npb25JZCxcclxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHN0YXRlLmFzc2Vzc21lbnQubGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBzdGF0ZS5hc3Nlc3NtZW50LmN1cnJlbnRTdGVwLFxyXG4gICAgICAgICAgICBzdGFydFRpbWU6IHN0YXRlLmFzc2Vzc21lbnQuc3RhcnRUaW1lIHx8IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgIGNvbXBsZXRpb25UaW1lOiBzdGF0ZS5hc3Nlc3NtZW50LmNvbXBsZXRpb25UaW1lLFxyXG4gICAgICAgICAgICBzZWxlY3RlZEZvcm1hdDogc3RhdGUuYXNzZXNzbWVudC5zZWxlY3RlZEZvcm1hdCxcclxuICAgICAgICAgICAgY29yZVJlc3BvbnNlczogc3RhdGUuYXNzZXNzbWVudC5jb3JlUmVzcG9uc2VzLFxyXG4gICAgICAgICAgICBleHRlbmRlZFJlc3BvbnNlczogc3RhdGUuYXNzZXNzbWVudC5leHRlbmRlZFJlc3BvbnNlcyxcclxuICAgICAgICAgICAgY2FsY3VsYXRlZFR5cGU6IHN0YXRlLmFzc2Vzc21lbnQuY2FsY3VsYXRlZFR5cGUsXHJcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IHN0YXRlLmFzc2Vzc21lbnQuY29uZmlkZW5jZSxcclxuICAgICAgICAgICAgcHJvZ3Jlc3M6IHN0YXRlLmFzc2Vzc21lbnQucHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgIGlzQ29tcGxldGU6IHN0YXRlLmFzc2Vzc21lbnQuaXNDb21wbGV0ZSxcclxuICAgICAgICAgICAgZm9ybWF0UHJvZ3Jlc3M6IHN0YXRlLmFzc2Vzc21lbnQuZm9ybWF0UHJvZ3Jlc3NcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVXBkYXRlIHNlc3Npb24gYWN0aXZpdHkgd2hlbiBwZXJzaXN0aW5nIHN0YXRlXHJcbiAgICAgICAgICBTZXNzaW9uU2VydmljZS51cGRhdGVBY3Rpdml0eSgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBzdG9yYWdlU2VydmljZS5zZXRJdGVtKHN0YXRlLmFzc2Vzc21lbnQuc2Vzc2lvbklkLCBzZXNzaW9uRGF0YSlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZXN0b3JlRnJvbVNlc3Npb246IChzZXNzaW9uSWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RvcmFnZVNlcnZpY2UuZ2V0SXRlbShzZXNzaW9uSWQpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmRhdGEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHJlc3VsdC5kYXRhXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIGFzc2Vzc21lbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuYXNzZXNzbWVudCxcclxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uRGF0YS5zZXNzaW9uSWQsXHJcbiAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBzZXNzaW9uRGF0YS5sYW5ndWFnZSxcclxuICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IHNlc3Npb25EYXRhLmN1cnJlbnRTdGVwLFxyXG4gICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHNlc3Npb25EYXRhLnN0YXJ0VGltZSA/IG5ldyBEYXRlKHNlc3Npb25EYXRhLnN0YXJ0VGltZSkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25UaW1lOiBzZXNzaW9uRGF0YS5jb21wbGV0aW9uVGltZSA/IG5ldyBEYXRlKHNlc3Npb25EYXRhLmNvbXBsZXRpb25UaW1lKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRGb3JtYXQ6IHNlc3Npb25EYXRhLnNlbGVjdGVkRm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgICBjb3JlUmVzcG9uc2VzOiBzZXNzaW9uRGF0YS5jb3JlUmVzcG9uc2VzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICBleHRlbmRlZFJlc3BvbnNlczogc2Vzc2lvbkRhdGEuZXh0ZW5kZWRSZXNwb25zZXMgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlczogWy4uLihzZXNzaW9uRGF0YS5jb3JlUmVzcG9uc2VzIHx8IFtdKSwgLi4uKHNlc3Npb25EYXRhLmV4dGVuZGVkUmVzcG9uc2VzIHx8IFtdKV0sXHJcbiAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRUeXBlOiBzZXNzaW9uRGF0YS5jYWxjdWxhdGVkVHlwZSxcclxuICAgICAgICAgICAgICAgICAgY29uZmlkZW5jZTogc2Vzc2lvbkRhdGEuY29uZmlkZW5jZSxcclxuICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHNlc3Npb25EYXRhLnByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiBzZXNzaW9uRGF0YS5pc0NvbXBsZXRlLFxyXG4gICAgICAgICAgICAgICAgICBmb3JtYXRQcm9ncmVzczogc2Vzc2lvbkRhdGEuZm9ybWF0UHJvZ3Jlc3NcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB1aToge1xyXG4gICAgICAgICAgICAgICAgICAuLi5zdGF0ZS51aSxcclxuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBzZXNzaW9uRGF0YS5sYW5ndWFnZSA9PT0gJ2FyJyA/ICdydGwnIDogJ2x0cidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZXN0b3JlIHNlc3Npb246JywgZXJyb3IpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgICBcclxuICAgICAgICAvLyBVSSBhY3Rpb25zXHJcbiAgICAgICAgc2V0VGhlbWU6ICh0aGVtZSkgPT5cclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICAgIHVpOiB7IC4uLnN0YXRlLnVpLCB0aGVtZSB9XHJcbiAgICAgICAgICB9KSksXHJcbiAgICAgICAgICBcclxuICAgICAgICBzZXREaXJlY3Rpb246IChkaXJlY3Rpb24pID0+XHJcbiAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgICAgICB1aTogeyAuLi5zdGF0ZS51aSwgZGlyZWN0aW9uIH1cclxuICAgICAgICAgIH0pKSxcclxuICAgICAgICAgIFxyXG4gICAgICAgIHRvZ2dsZVNpZGViYXI6ICgpID0+XHJcbiAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgICAgICB1aTogeyAuLi5zdGF0ZS51aSwgc2lkZWJhck9wZW46ICFzdGF0ZS51aS5zaWRlYmFyT3BlbiB9XHJcbiAgICAgICAgICB9KSksXHJcbiAgICAgICAgICBcclxuICAgICAgICBzZXRDdXJyZW50UGFnZTogKGN1cnJlbnRQYWdlKSA9PlxyXG4gICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICAgICAgdWk6IHsgLi4uc3RhdGUudWksIGN1cnJlbnRQYWdlIH1cclxuICAgICAgICAgIH0pKSxcclxuICAgICAgfSksXHJcbiAgICB7IG5hbWU6ICdNQlRJIEFwcCBTdG9yZScgfVxyXG4gIClcclxuKVxyXG5cclxuLy8gU2VsZWN0b3IgaG9va3MgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxyXG5leHBvcnQgY29uc3QgdXNlQXNzZXNzbWVudFN0b3JlID0gKCkgPT4gdXNlQXBwU3RvcmUoKHN0YXRlKSA9PiAoe1xyXG4gIHNlc3Npb25JZDogc3RhdGUuYXNzZXNzbWVudC5zZXNzaW9uSWQsXHJcbiAgY3VycmVudFN0ZXA6IHN0YXRlLmFzc2Vzc21lbnQuY3VycmVudFN0ZXAsXHJcbiAgbGFuZ3VhZ2U6IHN0YXRlLmFzc2Vzc21lbnQubGFuZ3VhZ2UsXHJcbiAgcmVzcG9uc2VzOiBzdGF0ZS5hc3Nlc3NtZW50LnJlc3BvbnNlcyxcclxuICBjb3JlUmVzcG9uc2VzOiBzdGF0ZS5hc3Nlc3NtZW50LmNvcmVSZXNwb25zZXMsXHJcbiAgZXh0ZW5kZWRSZXNwb25zZXM6IHN0YXRlLmFzc2Vzc21lbnQuZXh0ZW5kZWRSZXNwb25zZXMsXHJcbiAgc2VsZWN0ZWRGb3JtYXQ6IHN0YXRlLmFzc2Vzc21lbnQuc2VsZWN0ZWRGb3JtYXQsXHJcbiAgcHJvZ3Jlc3M6IHN0YXRlLmFzc2Vzc21lbnQucHJvZ3Jlc3MsXHJcbiAgaXNDb21wbGV0ZTogc3RhdGUuYXNzZXNzbWVudC5pc0NvbXBsZXRlLFxyXG4gIHN0YXJ0VGltZTogc3RhdGUuYXNzZXNzbWVudC5zdGFydFRpbWUsXHJcbiAgY29tcGxldGlvblRpbWU6IHN0YXRlLmFzc2Vzc21lbnQuY29tcGxldGlvblRpbWUsXHJcbiAgY2FsY3VsYXRlZFR5cGU6IHN0YXRlLmFzc2Vzc21lbnQuY2FsY3VsYXRlZFR5cGUsXHJcbiAgY29uZmlkZW5jZTogc3RhdGUuYXNzZXNzbWVudC5jb25maWRlbmNlLFxyXG4gIGludGVyaW1SZXN1bHRzOiBzdGF0ZS5hc3Nlc3NtZW50LmludGVyaW1SZXN1bHRzLFxyXG4gIGZvcm1hdFByb2dyZXNzOiBzdGF0ZS5hc3Nlc3NtZW50LmZvcm1hdFByb2dyZXNzLFxyXG4gIHJlc3VsdHM6IHN0YXRlLmFzc2Vzc21lbnQucmVzdWx0cyxcclxuICBzZXRTZXNzaW9uSWQ6IHN0YXRlLnNldFNlc3Npb25JZCxcclxuICBzZXRDdXJyZW50U3RlcDogc3RhdGUuc2V0Q3VycmVudFN0ZXAsXHJcbiAgc2V0TGFuZ3VhZ2U6IHN0YXRlLnNldExhbmd1YWdlLFxyXG4gIGFkZFJlc3BvbnNlOiBzdGF0ZS5hZGRSZXNwb25zZSxcclxuICBzZXRSZXNwb25zZXM6IHN0YXRlLnNldFJlc3BvbnNlcyxcclxuICBzZXRDb3JlUmVzcG9uc2VzOiBzdGF0ZS5zZXRDb3JlUmVzcG9uc2VzLFxyXG4gIHNldEV4dGVuZGVkUmVzcG9uc2VzOiBzdGF0ZS5zZXRFeHRlbmRlZFJlc3BvbnNlcyxcclxuICBzZXRTZWxlY3RlZEZvcm1hdDogc3RhdGUuc2V0U2VsZWN0ZWRGb3JtYXQsXHJcbiAgdXBkYXRlUHJvZ3Jlc3M6IHN0YXRlLnVwZGF0ZVByb2dyZXNzLFxyXG4gIHNldFByb2dyZXNzOiBzdGF0ZS5zZXRQcm9ncmVzcyxcclxuICBjYWxjdWxhdGVGb3JtYXRTcGVjaWZpY1Byb2dyZXNzOiBzdGF0ZS5jYWxjdWxhdGVGb3JtYXRTcGVjaWZpY1Byb2dyZXNzLFxyXG4gIHVwZGF0ZUZvcm1hdFByb2dyZXNzOiBzdGF0ZS51cGRhdGVGb3JtYXRQcm9ncmVzcyxcclxuICBjb21wbGV0ZUFzc2Vzc21lbnQ6IHN0YXRlLmNvbXBsZXRlQXNzZXNzbWVudCxcclxuICByZXNldEFzc2Vzc21lbnQ6IHN0YXRlLnJlc2V0QXNzZXNzbWVudCxcclxuICBzZXRJbnRlcmltUmVzdWx0czogc3RhdGUuc2V0SW50ZXJpbVJlc3VsdHMsXHJcbiAgc2V0UmVzdWx0czogc3RhdGUuc2V0UmVzdWx0cyxcclxuICBzZXRTdGFydFRpbWU6IHN0YXRlLnNldFN0YXJ0VGltZSxcclxuICBzZXRDb21wbGV0aW9uVGltZTogc3RhdGUuc2V0Q29tcGxldGlvblRpbWUsXHJcbiAgc2V0Q2FsY3VsYXRlZFR5cGU6IHN0YXRlLnNldENhbGN1bGF0ZWRUeXBlLFxyXG4gIHNldENvbmZpZGVuY2U6IHN0YXRlLnNldENvbmZpZGVuY2UsXHJcbiAgcGVyc2lzdFN0YXRlOiBzdGF0ZS5wZXJzaXN0U3RhdGUsXHJcbiAgcmVzdG9yZUZyb21TZXNzaW9uOiBzdGF0ZS5yZXN0b3JlRnJvbVNlc3Npb24sXHJcbn0pKVxyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVVJU3RvcmUgPSAoKSA9PiB1c2VBcHBTdG9yZSgoc3RhdGUpID0+ICh7XHJcbiAgdGhlbWU6IHN0YXRlLnVpLnRoZW1lLFxyXG4gIGRpcmVjdGlvbjogc3RhdGUudWkuZGlyZWN0aW9uLFxyXG4gIHNpZGViYXJPcGVuOiBzdGF0ZS51aS5zaWRlYmFyT3BlbixcclxuICBjdXJyZW50UGFnZTogc3RhdGUudWkuY3VycmVudFBhZ2UsXHJcbiAgc2V0VGhlbWU6IHN0YXRlLnNldFRoZW1lLFxyXG4gIHNldERpcmVjdGlvbjogc3RhdGUuc2V0RGlyZWN0aW9uLFxyXG4gIHRvZ2dsZVNpZGViYXI6IHN0YXRlLnRvZ2dsZVNpZGViYXIsICBcclxuICBzZXRDdXJyZW50UGFnZTogc3RhdGUuc2V0Q3VycmVudFBhZ2UsXHJcbn0pKVxyXG5cclxuIl0sIm5hbWVzIjpbImNyZWF0ZSIsImRldnRvb2xzIiwic3RvcmFnZVNlcnZpY2UiLCJTZXNzaW9uU2VydmljZSIsIkNPUkVfUVVFU1RJT05TX0NPVU5UIiwiVE9UQUxfUVVFU1RJT05TIiwiUVVFU1RJT05fUE9PTFMiLCJQUk9HUkVTU19NSUxFU1RPTkVTIiwiaW5pdGlhbEFzc2Vzc21lbnRTdGF0ZSIsInNlc3Npb25JZCIsImN1cnJlbnRTdGVwIiwibGFuZ3VhZ2UiLCJyZXNwb25zZXMiLCJjb3JlUmVzcG9uc2VzIiwiZXh0ZW5kZWRSZXNwb25zZXMiLCJzZWxlY3RlZEZvcm1hdCIsInByb2dyZXNzIiwiaXNDb21wbGV0ZSIsImluaXRpYWxVSVN0YXRlIiwidGhlbWUiLCJkaXJlY3Rpb24iLCJzaWRlYmFyT3BlbiIsImN1cnJlbnRQYWdlIiwidXNlQXBwU3RvcmUiLCJzZXQiLCJnZXQiLCJhc3Nlc3NtZW50IiwidWkiLCJzZXRTZXNzaW9uSWQiLCJpbml0aWFsaXplU2Vzc2lvbiIsInN0YXRlIiwic2V0Q3VycmVudFN0ZXAiLCJzZXRMYW5ndWFnZSIsImFkZFJlc3BvbnNlIiwicmVzcG9uc2UiLCJleGlzdGluZ0luZGV4IiwiZmluZEluZGV4IiwiciIsInF1ZXN0aW9uSWQiLCJuZXdSZXNwb25zZXMiLCJuZXdDb3JlUmVzcG9uc2VzIiwibmV3RXh0ZW5kZWRSZXNwb25zZXMiLCJxdWVzdGlvblR5cGUiLCJjb3JlSW5kZXgiLCJwdXNoIiwiZXh0ZW5kZWRJbmRleCIsInVwZGF0ZWRBc3Nlc3NtZW50Iiwic2V0VGltZW91dCIsInBlcnNpc3RTdGF0ZSIsInNldFJlc3BvbnNlcyIsImZpbHRlciIsInNldENvcmVSZXNwb25zZXMiLCJzZXRFeHRlbmRlZFJlc3BvbnNlcyIsInNldFNlbGVjdGVkRm9ybWF0IiwidHJhbnNpdGlvblRvRXh0ZW5kZWRQaGFzZSIsImZvcm1hdFByb2dyZXNzIiwidG90YWxRdWVzdGlvbnMiLCJjdXJyZW50UXVlc3Rpb25JbmRleCIsImNvbXBsZXRlZFF1ZXN0aW9ucyIsInF1ZXN0aW9uUG9vbCIsImZvcm1hdFNlbGVjdGVkIiwidXBkYXRlUHJvZ3Jlc3MiLCJzZXRQcm9ncmVzcyIsImNhbGN1bGF0ZUZvcm1hdFNwZWNpZmljUHJvZ3Jlc3MiLCJsZW5ndGgiLCJjb3JlQ29tcGxldGUiLCJ0b3RhbENvbXBsZXRlZCIsIk1hdGgiLCJtaW4iLCJyb3VuZCIsInVwZGF0ZUZvcm1hdFByb2dyZXNzIiwiY3VycmVudEluZGV4IiwidXBkYXRlZEZvcm1hdFByb2dyZXNzIiwibmV3UHJvZ3Jlc3MiLCJjb21wbGV0ZUFzc2Vzc21lbnQiLCJyZXNldEFzc2Vzc21lbnQiLCJzZXRJbnRlcmltUmVzdWx0cyIsImludGVyaW1SZXN1bHRzIiwic2V0UmVzdWx0cyIsInJlc3VsdHMiLCJzZXRTdGFydFRpbWUiLCJzdGFydFRpbWUiLCJzZXRDb21wbGV0aW9uVGltZSIsImNvbXBsZXRpb25UaW1lIiwic2V0Q2FsY3VsYXRlZFR5cGUiLCJjYWxjdWxhdGVkVHlwZSIsInNldENvbmZpZGVuY2UiLCJjb25maWRlbmNlIiwic2Vzc2lvbkRhdGEiLCJEYXRlIiwidXBkYXRlQWN0aXZpdHkiLCJzZXRJdGVtIiwicmVzdG9yZUZyb21TZXNzaW9uIiwicmVzdWx0IiwiZ2V0SXRlbSIsInN1Y2Nlc3MiLCJkYXRhIiwidW5kZWZpbmVkIiwiZXJyb3IiLCJjb25zb2xlIiwic2V0VGhlbWUiLCJzZXREaXJlY3Rpb24iLCJ0b2dnbGVTaWRlYmFyIiwic2V0Q3VycmVudFBhZ2UiLCJuYW1lIiwidXNlQXNzZXNzbWVudFN0b3JlIiwidXNlVUlTdG9yZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/stores/assessment-store.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz82NDcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/ZjRkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zustand/esm/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/zustand/esm/index.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: function() { return /* binding */ create; },\n/* harmony export */   createStore: function() { return /* reexport safe */ zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__.createStore; },\n/* harmony export */   \"default\": function() { return /* binding */ react; },\n/* harmony export */   useStore: function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand/vanilla */ \"(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n\n\n\n\n\nconst { useDebugValue } = react__WEBPACK_IMPORTED_MODULE_1__;\nconst { useSyncExternalStoreWithSelector } = use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__;\nlet didWarnAboutEqualityFn = false;\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity, equalityFn) {\n  if (( false ? 0 : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n    console.warn(\n      \"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\"\n    );\n    didWarnAboutEqualityFn = true;\n  }\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if (( false ? 0 : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__.createStore)(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE4QztBQUNkO0FBQ0M7QUFDdUQ7O0FBRXhGLFFBQVEsZ0JBQWdCLEVBQUUsa0NBQVk7QUFDdEMsUUFBUSxtQ0FBbUMsRUFBRSwwRUFBMkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBLDJHQUEyRyxXQUFXO0FBQ3RIO0FBQ0E7QUFDQSxrREFBa0QsNERBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQSx3RUFBd0UsU0FBUztBQUNqRjtBQUNBO0FBQ0E7QUFDQTs7QUFFOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL2luZGV4Lm1qcz9mMDdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAnenVzdGFuZC92YW5pbGxhJztcbmV4cG9ydCAqIGZyb20gJ3p1c3RhbmQvdmFuaWxsYSc7XG5pbXBvcnQgUmVhY3RFeHBvcnRzIGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZUV4cG9ydHMgZnJvbSAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzJztcblxuY29uc3QgeyB1c2VEZWJ1Z1ZhbHVlIH0gPSBSZWFjdEV4cG9ydHM7XG5jb25zdCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZUV4cG9ydHM7XG5sZXQgZGlkV2FybkFib3V0RXF1YWxpdHlGbiA9IGZhbHNlO1xuY29uc3QgaWRlbnRpdHkgPSAoYXJnKSA9PiBhcmc7XG5mdW5jdGlvbiB1c2VTdG9yZShhcGksIHNlbGVjdG9yID0gaWRlbnRpdHksIGVxdWFsaXR5Rm4pIHtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGVxdWFsaXR5Rm4gJiYgIWRpZFdhcm5BYm91dEVxdWFsaXR5Rm4pIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIltERVBSRUNBVEVEXSBVc2UgYGNyZWF0ZVdpdGhFcXVhbGl0eUZuYCBpbnN0ZWFkIG9mIGBjcmVhdGVgIG9yIHVzZSBgdXNlU3RvcmVXaXRoRXF1YWxpdHlGbmAgaW5zdGVhZCBvZiBgdXNlU3RvcmVgLiBUaGV5IGNhbiBiZSBpbXBvcnRlZCBmcm9tICd6dXN0YW5kL3RyYWRpdGlvbmFsJy4gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy96dXN0YW5kL2Rpc2N1c3Npb25zLzE5MzdcIlxuICAgICk7XG4gICAgZGlkV2FybkFib3V0RXF1YWxpdHlGbiA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc2xpY2UgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBhcGkuc3Vic2NyaWJlLFxuICAgIGFwaS5nZXRTdGF0ZSxcbiAgICBhcGkuZ2V0U2VydmVyU3RhdGUgfHwgYXBpLmdldEluaXRpYWxTdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBlcXVhbGl0eUZuXG4gICk7XG4gIHVzZURlYnVnVmFsdWUoc2xpY2UpO1xuICByZXR1cm4gc2xpY2U7XG59XG5jb25zdCBjcmVhdGVJbXBsID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2YgY3JlYXRlU3RhdGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0RFUFJFQ0FURURdIFBhc3NpbmcgYSB2YW5pbGxhIHN0b3JlIHdpbGwgYmUgdW5zdXBwb3J0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gSW5zdGVhZCB1c2UgYGltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnenVzdGFuZCdgLlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBhcGkgPSB0eXBlb2YgY3JlYXRlU3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0YXRlO1xuICBjb25zdCB1c2VCb3VuZFN0b3JlID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSA9PiB1c2VTdG9yZShhcGksIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbiAgT2JqZWN0LmFzc2lnbih1c2VCb3VuZFN0b3JlLCBhcGkpO1xuICByZXR1cm4gdXNlQm91bmRTdG9yZTtcbn07XG5jb25zdCBjcmVhdGUgPSAoY3JlYXRlU3RhdGUpID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlSW1wbChjcmVhdGVTdGF0ZSkgOiBjcmVhdGVJbXBsO1xudmFyIHJlYWN0ID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0RFUFJFQ0FURURdIERlZmF1bHQgZXhwb3J0IGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGBpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJ2AuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGUoY3JlYXRlU3RhdGUpO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlLCByZWFjdCBhcyBkZWZhdWx0LCB1c2VTdG9yZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zustand/esm/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs":
/*!*************************************************!*\
  !*** ./node_modules/zustand/esm/middleware.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   combine: function() { return /* binding */ combine; },\n/* harmony export */   createJSONStorage: function() { return /* binding */ createJSONStorage; },\n/* harmony export */   devtools: function() { return /* binding */ devtools; },\n/* harmony export */   persist: function() { return /* binding */ persist; },\n/* harmony export */   redux: function() { return /* binding */ redux; },\n/* harmony export */   subscribeWithSelector: function() { return /* binding */ subscribeWithSelector; }\n/* harmony export */ });\nconst reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : ( false ? 0 : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (_e) {\n  }\n  if (!extensionConnector) {\n    if (( false ? 0 : void 0) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if (( false ? 0 : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState) return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0) f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (_e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (_e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return [\n              true,\n              options.migrate(\n                deserializedStorageValue.state,\n                deserializedStorageValue.version\n              )\n            ];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, void 0];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if (( false ? 0 : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9taWRkbGV3YXJlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDhDQUE4QztBQUM5QyxVQUFVLGtEQUFrRDtBQUM1RDtBQUNBO0FBQ0EsdURBQXVELE1BQWUsR0FBRyxDQUFvQjtBQUM3RixJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVMsTUFBZSxHQUFHLENBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUNBQXVDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJDQUEyQyx1Q0FBdUMscUJBQXFCO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU0sR0FBRyxZQUFZO0FBQ3RDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFlLEdBQUcsQ0FBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsaUNBQWlDLGlCQUFpQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsYUFBYTtBQUM5RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0EseUNBQXlDLGlDQUFpQztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGFBQWE7QUFDOUU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBZSxHQUFHLENBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL21pZGRsZXdhcmUubWpzPzY3OWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVkdXhJbXBsID0gKHJlZHVjZXIsIGluaXRpYWwpID0+IChzZXQsIF9nZXQsIGFwaSkgPT4ge1xuICBhcGkuZGlzcGF0Y2ggPSAoYWN0aW9uKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSwgZmFsc2UsIGFjdGlvbik7XG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfTtcbiAgYXBpLmRpc3BhdGNoRnJvbURldnRvb2xzID0gdHJ1ZTtcbiAgcmV0dXJuIHsgZGlzcGF0Y2g6ICguLi5hKSA9PiBhcGkuZGlzcGF0Y2goLi4uYSksIC4uLmluaXRpYWwgfTtcbn07XG5jb25zdCByZWR1eCA9IHJlZHV4SW1wbDtcblxuY29uc3QgdHJhY2tlZENvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmNvbnN0IGdldFRyYWNrZWRDb25uZWN0aW9uU3RhdGUgPSAobmFtZSkgPT4ge1xuICBjb25zdCBhcGkgPSB0cmFja2VkQ29ubmVjdGlvbnMuZ2V0KG5hbWUpO1xuICBpZiAoIWFwaSkgcmV0dXJuIHt9O1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKGFwaS5zdG9yZXMpLm1hcCgoW2tleSwgYXBpMl0pID0+IFtrZXksIGFwaTIuZ2V0U3RhdGUoKV0pXG4gICk7XG59O1xuY29uc3QgZXh0cmFjdENvbm5lY3Rpb25JbmZvcm1hdGlvbiA9IChzdG9yZSwgZXh0ZW5zaW9uQ29ubmVjdG9yLCBvcHRpb25zKSA9PiB7XG4gIGlmIChzdG9yZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidW50cmFja2VkXCIsXG4gICAgICBjb25uZWN0aW9uOiBleHRlbnNpb25Db25uZWN0b3IuY29ubmVjdChvcHRpb25zKVxuICAgIH07XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb25uZWN0aW9uID0gdHJhY2tlZENvbm5lY3Rpb25zLmdldChvcHRpb25zLm5hbWUpO1xuICBpZiAoZXhpc3RpbmdDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0cmFja2VkXCIsIHN0b3JlLCAuLi5leGlzdGluZ0Nvbm5lY3Rpb24gfTtcbiAgfVxuICBjb25zdCBuZXdDb25uZWN0aW9uID0ge1xuICAgIGNvbm5lY3Rpb246IGV4dGVuc2lvbkNvbm5lY3Rvci5jb25uZWN0KG9wdGlvbnMpLFxuICAgIHN0b3Jlczoge31cbiAgfTtcbiAgdHJhY2tlZENvbm5lY3Rpb25zLnNldChvcHRpb25zLm5hbWUsIG5ld0Nvbm5lY3Rpb24pO1xuICByZXR1cm4geyB0eXBlOiBcInRyYWNrZWRcIiwgc3RvcmUsIC4uLm5ld0Nvbm5lY3Rpb24gfTtcbn07XG5jb25zdCBkZXZ0b29sc0ltcGwgPSAoZm4sIGRldnRvb2xzT3B0aW9ucyA9IHt9KSA9PiAoc2V0LCBnZXQsIGFwaSkgPT4ge1xuICBjb25zdCB7IGVuYWJsZWQsIGFub255bW91c0FjdGlvblR5cGUsIHN0b3JlLCAuLi5vcHRpb25zIH0gPSBkZXZ0b29sc09wdGlvbnM7XG4gIGxldCBleHRlbnNpb25Db25uZWN0b3I7XG4gIHRyeSB7XG4gICAgZXh0ZW5zaW9uQ29ubmVjdG9yID0gKGVuYWJsZWQgIT0gbnVsbCA/IGVuYWJsZWQgOiAoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX187XG4gIH0gY2F0Y2ggKF9lKSB7XG4gIH1cbiAgaWYgKCFleHRlbnNpb25Db25uZWN0b3IpIHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZW5hYmxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIlt6dXN0YW5kIGRldnRvb2xzIG1pZGRsZXdhcmVdIFBsZWFzZSBpbnN0YWxsL2VuYWJsZSBSZWR1eCBkZXZ0b29scyBleHRlbnNpb25cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZuKHNldCwgZ2V0LCBhcGkpO1xuICB9XG4gIGNvbnN0IHsgY29ubmVjdGlvbiwgLi4uY29ubmVjdGlvbkluZm9ybWF0aW9uIH0gPSBleHRyYWN0Q29ubmVjdGlvbkluZm9ybWF0aW9uKHN0b3JlLCBleHRlbnNpb25Db25uZWN0b3IsIG9wdGlvbnMpO1xuICBsZXQgaXNSZWNvcmRpbmcgPSB0cnVlO1xuICBhcGkuc2V0U3RhdGUgPSAoc3RhdGUsIHJlcGxhY2UsIG5hbWVPckFjdGlvbikgPT4ge1xuICAgIGNvbnN0IHIgPSBzZXQoc3RhdGUsIHJlcGxhY2UpO1xuICAgIGlmICghaXNSZWNvcmRpbmcpIHJldHVybiByO1xuICAgIGNvbnN0IGFjdGlvbiA9IG5hbWVPckFjdGlvbiA9PT0gdm9pZCAwID8geyB0eXBlOiBhbm9ueW1vdXNBY3Rpb25UeXBlIHx8IFwiYW5vbnltb3VzXCIgfSA6IHR5cGVvZiBuYW1lT3JBY3Rpb24gPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IG5hbWVPckFjdGlvbiB9IDogbmFtZU9yQWN0aW9uO1xuICAgIGlmIChzdG9yZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLnNlbmQoYWN0aW9uLCBnZXQoKSk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5zZW5kKFxuICAgICAge1xuICAgICAgICAuLi5hY3Rpb24sXG4gICAgICAgIHR5cGU6IGAke3N0b3JlfS8ke2FjdGlvbi50eXBlfWBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC4uLmdldFRyYWNrZWRDb25uZWN0aW9uU3RhdGUob3B0aW9ucy5uYW1lKSxcbiAgICAgICAgW3N0b3JlXTogYXBpLmdldFN0YXRlKClcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiByO1xuICB9O1xuICBjb25zdCBzZXRTdGF0ZUZyb21EZXZ0b29scyA9ICguLi5hKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxJc1JlY29yZGluZyA9IGlzUmVjb3JkaW5nO1xuICAgIGlzUmVjb3JkaW5nID0gZmFsc2U7XG4gICAgc2V0KC4uLmEpO1xuICAgIGlzUmVjb3JkaW5nID0gb3JpZ2luYWxJc1JlY29yZGluZztcbiAgfTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gZm4oYXBpLnNldFN0YXRlLCBnZXQsIGFwaSk7XG4gIGlmIChjb25uZWN0aW9uSW5mb3JtYXRpb24udHlwZSA9PT0gXCJ1bnRyYWNrZWRcIikge1xuICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChpbml0aWFsU3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIGNvbm5lY3Rpb25JbmZvcm1hdGlvbi5zdG9yZXNbY29ubmVjdGlvbkluZm9ybWF0aW9uLnN0b3JlXSA9IGFwaTtcbiAgICBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmluaXQoXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbm5lY3Rpb25JbmZvcm1hdGlvbi5zdG9yZXMpLm1hcCgoW2tleSwgc3RvcmUyXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBrZXkgPT09IGNvbm5lY3Rpb25JbmZvcm1hdGlvbi5zdG9yZSA/IGluaXRpYWxTdGF0ZSA6IHN0b3JlMi5nZXRTdGF0ZSgpXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBpZiAoYXBpLmRpc3BhdGNoRnJvbURldnRvb2xzICYmIHR5cGVvZiBhcGkuZGlzcGF0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGxldCBkaWRXYXJuQWJvdXRSZXNlcnZlZEFjdGlvblR5cGUgPSBmYWxzZTtcbiAgICBjb25zdCBvcmlnaW5hbERpc3BhdGNoID0gYXBpLmRpc3BhdGNoO1xuICAgIGFwaS5kaXNwYXRjaCA9ICguLi5hKSA9PiB7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYVswXS50eXBlID09PSBcIl9fc2V0U3RhdGVcIiAmJiAhZGlkV2FybkFib3V0UmVzZXJ2ZWRBY3Rpb25UeXBlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnW3p1c3RhbmQgZGV2dG9vbHMgbWlkZGxld2FyZV0gXCJfX3NldFN0YXRlXCIgYWN0aW9uIHR5cGUgaXMgcmVzZXJ2ZWQgdG8gc2V0IHN0YXRlIGZyb20gdGhlIGRldnRvb2xzLiBBdm9pZCB1c2luZyBpdC4nXG4gICAgICAgICk7XG4gICAgICAgIGRpZFdhcm5BYm91dFJlc2VydmVkQWN0aW9uVHlwZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBvcmlnaW5hbERpc3BhdGNoKC4uLmEpO1xuICAgIH07XG4gIH1cbiAgY29ubmVjdGlvbi5zdWJzY3JpYmUoKG1lc3NhZ2UpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJBQ1RJT05cIjpcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnBheWxvYWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXSBVbnN1cHBvcnRlZCBhY3Rpb24gZm9ybWF0XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VKc29uVGhlbihcbiAgICAgICAgICBtZXNzYWdlLnBheWxvYWQsXG4gICAgICAgICAgKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBcIl9fc2V0U3RhdGVcIikge1xuICAgICAgICAgICAgICBpZiAoc3RvcmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKGFjdGlvbi5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhY3Rpb24uc3RhdGUpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgIFt6dXN0YW5kIGRldnRvb2xzIG1pZGRsZXdhcmVdIFVuc3VwcG9ydGVkIF9fc2V0U3RhdGUgYWN0aW9uIGZvcm1hdC4gXG4gICAgICAgICAgICAgICAgICAgIFdoZW4gdXNpbmcgJ3N0b3JlJyBvcHRpb24gaW4gZGV2dG9vbHMoKSwgdGhlICdzdGF0ZScgc2hvdWxkIGhhdmUgb25seSBvbmUga2V5LCB3aGljaCBpcyBhIHZhbHVlIG9mICdzdG9yZScgdGhhdCB3YXMgcGFzc2VkIGluIGRldnRvb2xzKCksXG4gICAgICAgICAgICAgICAgICAgIGFuZCB2YWx1ZSBvZiB0aGlzIG9ubHkga2V5IHNob3VsZCBiZSBhIHN0YXRlIG9iamVjdC4gRXhhbXBsZTogeyBcInR5cGVcIjogXCJfX3NldFN0YXRlXCIsIFwic3RhdGVcIjogeyBcImFiYzEyM1N0b3JlXCI6IHsgXCJmb29cIjogXCJiYXJcIiB9IH0gfVxuICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBzdGF0ZUZyb21EZXZ0b29scyA9IGFjdGlvbi5zdGF0ZVtzdG9yZV07XG4gICAgICAgICAgICAgIGlmIChzdGF0ZUZyb21EZXZ0b29scyA9PT0gdm9pZCAwIHx8IHN0YXRlRnJvbURldnRvb2xzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShhcGkuZ2V0U3RhdGUoKSkgIT09IEpTT04uc3RyaW5naWZ5KHN0YXRlRnJvbURldnRvb2xzKSkge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKHN0YXRlRnJvbURldnRvb2xzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFwaS5kaXNwYXRjaEZyb21EZXZ0b29scykgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcGkuZGlzcGF0Y2ggIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuO1xuICAgICAgICAgICAgYXBpLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgY2FzZSBcIkRJU1BBVENIXCI6XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5wYXlsb2FkLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiUkVTRVRcIjpcbiAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgICAgICBpZiAoc3RvcmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5pbml0KGFwaS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmluaXQoZ2V0VHJhY2tlZENvbm5lY3Rpb25TdGF0ZShvcHRpb25zLm5hbWUpKTtcbiAgICAgICAgICBjYXNlIFwiQ09NTUlUXCI6XG4gICAgICAgICAgICBpZiAoc3RvcmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmluaXQoYXBpLmdldFN0YXRlKCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5pbml0KGdldFRyYWNrZWRDb25uZWN0aW9uU3RhdGUob3B0aW9ucy5uYW1lKSk7XG4gICAgICAgICAgY2FzZSBcIlJPTExCQUNLXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VKc29uVGhlbihtZXNzYWdlLnN0YXRlLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5pbml0KGFwaS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoc3RhdGVbc3RvcmVdKTtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5pbml0KGdldFRyYWNrZWRDb25uZWN0aW9uU3RhdGUob3B0aW9ucy5uYW1lKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIFwiSlVNUF9UT19TVEFURVwiOlxuICAgICAgICAgIGNhc2UgXCJKVU1QX1RPX0FDVElPTlwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSnNvblRoZW4obWVzc2FnZS5zdGF0ZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChzdG9yZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoYXBpLmdldFN0YXRlKCkpICE9PSBKU09OLnN0cmluZ2lmeShzdGF0ZVtzdG9yZV0pKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoc3RhdGVbc3RvcmVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSBcIklNUE9SVF9TVEFURVwiOiB7XG4gICAgICAgICAgICBjb25zdCB7IG5leHRMaWZ0ZWRTdGF0ZSB9ID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgICAgICAgICAgY29uc3QgbGFzdENvbXB1dGVkU3RhdGUgPSAoX2EgPSBuZXh0TGlmdGVkU3RhdGUuY29tcHV0ZWRTdGF0ZXMuc2xpY2UoLTEpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RhdGU7XG4gICAgICAgICAgICBpZiAoIWxhc3RDb21wdXRlZFN0YXRlKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoc3RvcmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhsYXN0Q29tcHV0ZWRTdGF0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhsYXN0Q29tcHV0ZWRTdGF0ZVtzdG9yZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5zZW5kKFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAvLyBGSVhNRSBuby1hbnlcbiAgICAgICAgICAgICAgbmV4dExpZnRlZFN0YXRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiUEFVU0VfUkVDT1JESU5HXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNSZWNvcmRpbmcgPSAhaXNSZWNvcmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbml0aWFsU3RhdGU7XG59O1xuY29uc3QgZGV2dG9vbHMgPSBkZXZ0b29sc0ltcGw7XG5jb25zdCBwYXJzZUpzb25UaGVuID0gKHN0cmluZ2lmaWVkLCBmKSA9PiB7XG4gIGxldCBwYXJzZWQ7XG4gIHRyeSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZShzdHJpbmdpZmllZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXSBDb3VsZCBub3QgcGFyc2UgdGhlIHJlY2VpdmVkIGpzb25cIixcbiAgICAgIGVcbiAgICApO1xuICB9XG4gIGlmIChwYXJzZWQgIT09IHZvaWQgMCkgZihwYXJzZWQpO1xufTtcblxuY29uc3Qgc3Vic2NyaWJlV2l0aFNlbGVjdG9ySW1wbCA9IChmbikgPT4gKHNldCwgZ2V0LCBhcGkpID0+IHtcbiAgY29uc3Qgb3JpZ1N1YnNjcmliZSA9IGFwaS5zdWJzY3JpYmU7XG4gIGFwaS5zdWJzY3JpYmUgPSAoc2VsZWN0b3IsIG9wdExpc3RlbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgbGV0IGxpc3RlbmVyID0gc2VsZWN0b3I7XG4gICAgaWYgKG9wdExpc3RlbmVyKSB7XG4gICAgICBjb25zdCBlcXVhbGl0eUZuID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZXF1YWxpdHlGbikgfHwgT2JqZWN0LmlzO1xuICAgICAgbGV0IGN1cnJlbnRTbGljZSA9IHNlbGVjdG9yKGFwaS5nZXRTdGF0ZSgpKTtcbiAgICAgIGxpc3RlbmVyID0gKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRTbGljZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgaWYgKCFlcXVhbGl0eUZuKGN1cnJlbnRTbGljZSwgbmV4dFNsaWNlKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzU2xpY2UgPSBjdXJyZW50U2xpY2U7XG4gICAgICAgICAgb3B0TGlzdGVuZXIoY3VycmVudFNsaWNlID0gbmV4dFNsaWNlLCBwcmV2aW91c1NsaWNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgICBvcHRMaXN0ZW5lcihjdXJyZW50U2xpY2UsIGN1cnJlbnRTbGljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmlnU3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gZm4oc2V0LCBnZXQsIGFwaSk7XG4gIHJldHVybiBpbml0aWFsU3RhdGU7XG59O1xuY29uc3Qgc3Vic2NyaWJlV2l0aFNlbGVjdG9yID0gc3Vic2NyaWJlV2l0aFNlbGVjdG9ySW1wbDtcblxuY29uc3QgY29tYmluZSA9IChpbml0aWFsU3RhdGUsIGNyZWF0ZSkgPT4gKC4uLmEpID0+IE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwgY3JlYXRlKC4uLmEpKTtcblxuZnVuY3Rpb24gY3JlYXRlSlNPTlN0b3JhZ2UoZ2V0U3RvcmFnZSwgb3B0aW9ucykge1xuICBsZXQgc3RvcmFnZTtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlID0gZ2V0U3RvcmFnZSgpO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwZXJzaXN0U3RvcmFnZSA9IHtcbiAgICBnZXRJdGVtOiAobmFtZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgcGFyc2UgPSAoc3RyMikgPT4ge1xuICAgICAgICBpZiAoc3RyMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cjIsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmV2aXZlcik7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3RyID0gKF9hID0gc3RvcmFnZS5nZXRJdGVtKG5hbWUpKSAhPSBudWxsID8gX2EgOiBudWxsO1xuICAgICAgaWYgKHN0ciBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHN0ci50aGVuKHBhcnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZShzdHIpO1xuICAgIH0sXG4gICAgc2V0SXRlbTogKG5hbWUsIG5ld1ZhbHVlKSA9PiBzdG9yYWdlLnNldEl0ZW0oXG4gICAgICBuYW1lLFxuICAgICAgSlNPTi5zdHJpbmdpZnkobmV3VmFsdWUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmVwbGFjZXIpXG4gICAgKSxcbiAgICByZW1vdmVJdGVtOiAobmFtZSkgPT4gc3RvcmFnZS5yZW1vdmVJdGVtKG5hbWUpXG4gIH07XG4gIHJldHVybiBwZXJzaXN0U3RvcmFnZTtcbn1cbmNvbnN0IHRvVGhlbmFibGUgPSAoZm4pID0+IChpbnB1dCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKGlucHV0KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRvVGhlbmFibGUob25GdWxmaWxsZWQpKHJlc3VsdCk7XG4gICAgICB9LFxuICAgICAgY2F0Y2goX29uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0aGVuKF9vbkZ1bGZpbGxlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0b1RoZW5hYmxlKG9uUmVqZWN0ZWQpKGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5jb25zdCBvbGRJbXBsID0gKGNvbmZpZywgYmFzZU9wdGlvbnMpID0+IChzZXQsIGdldCwgYXBpKSA9PiB7XG4gIGxldCBvcHRpb25zID0ge1xuICAgIGdldFN0b3JhZ2U6ICgpID0+IGxvY2FsU3RvcmFnZSxcbiAgICBzZXJpYWxpemU6IEpTT04uc3RyaW5naWZ5LFxuICAgIGRlc2VyaWFsaXplOiBKU09OLnBhcnNlLFxuICAgIHBhcnRpYWxpemU6IChzdGF0ZSkgPT4gc3RhdGUsXG4gICAgdmVyc2lvbjogMCxcbiAgICBtZXJnZTogKHBlcnNpc3RlZFN0YXRlLCBjdXJyZW50U3RhdGUpID0+ICh7XG4gICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICAuLi5wZXJzaXN0ZWRTdGF0ZVxuICAgIH0pLFxuICAgIC4uLmJhc2VPcHRpb25zXG4gIH07XG4gIGxldCBoYXNIeWRyYXRlZCA9IGZhbHNlO1xuICBjb25zdCBoeWRyYXRpb25MaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgc3RvcmFnZTtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlID0gb3B0aW9ucy5nZXRTdG9yYWdlKCk7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gIH1cbiAgaWYgKCFzdG9yYWdlKSB7XG4gICAgcmV0dXJuIGNvbmZpZyhcbiAgICAgICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgW3p1c3RhbmQgcGVyc2lzdCBtaWRkbGV3YXJlXSBVbmFibGUgdG8gdXBkYXRlIGl0ZW0gJyR7b3B0aW9ucy5uYW1lfScsIHRoZSBnaXZlbiBzdG9yYWdlIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZS5gXG4gICAgICAgICk7XG4gICAgICAgIHNldCguLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBnZXQsXG4gICAgICBhcGlcbiAgICApO1xuICB9XG4gIGNvbnN0IHRoZW5hYmxlU2VyaWFsaXplID0gdG9UaGVuYWJsZShvcHRpb25zLnNlcmlhbGl6ZSk7XG4gIGNvbnN0IHNldEl0ZW0gPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBvcHRpb25zLnBhcnRpYWxpemUoeyAuLi5nZXQoKSB9KTtcbiAgICBsZXQgZXJyb3JJblN5bmM7XG4gICAgY29uc3QgdGhlbmFibGUgPSB0aGVuYWJsZVNlcmlhbGl6ZSh7IHN0YXRlLCB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24gfSkudGhlbihcbiAgICAgIChzZXJpYWxpemVkVmFsdWUpID0+IHN0b3JhZ2Uuc2V0SXRlbShvcHRpb25zLm5hbWUsIHNlcmlhbGl6ZWRWYWx1ZSlcbiAgICApLmNhdGNoKChlKSA9PiB7XG4gICAgICBlcnJvckluU3luYyA9IGU7XG4gICAgfSk7XG4gICAgaWYgKGVycm9ySW5TeW5jKSB7XG4gICAgICB0aHJvdyBlcnJvckluU3luYztcbiAgICB9XG4gICAgcmV0dXJuIHRoZW5hYmxlO1xuICB9O1xuICBjb25zdCBzYXZlZFNldFN0YXRlID0gYXBpLnNldFN0YXRlO1xuICBhcGkuc2V0U3RhdGUgPSAoc3RhdGUsIHJlcGxhY2UpID0+IHtcbiAgICBzYXZlZFNldFN0YXRlKHN0YXRlLCByZXBsYWNlKTtcbiAgICB2b2lkIHNldEl0ZW0oKTtcbiAgfTtcbiAgY29uc3QgY29uZmlnUmVzdWx0ID0gY29uZmlnKFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBzZXQoLi4uYXJncyk7XG4gICAgICB2b2lkIHNldEl0ZW0oKTtcbiAgICB9LFxuICAgIGdldCxcbiAgICBhcGlcbiAgKTtcbiAgbGV0IHN0YXRlRnJvbVN0b3JhZ2U7XG4gIGNvbnN0IGh5ZHJhdGUgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghc3RvcmFnZSkgcmV0dXJuO1xuICAgIGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uTGlzdGVuZXJzLmZvckVhY2goKGNiKSA9PiBjYihnZXQoKSkpO1xuICAgIGNvbnN0IHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID0gKChfYSA9IG9wdGlvbnMub25SZWh5ZHJhdGVTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBnZXQoKSkpIHx8IHZvaWQgMDtcbiAgICByZXR1cm4gdG9UaGVuYWJsZShzdG9yYWdlLmdldEl0ZW0uYmluZChzdG9yYWdlKSkob3B0aW9ucy5uYW1lKS50aGVuKChzdG9yYWdlVmFsdWUpID0+IHtcbiAgICAgIGlmIChzdG9yYWdlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVzZXJpYWxpemUoc3RvcmFnZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9KS50aGVuKChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpID0+IHtcbiAgICAgIGlmIChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiA9PT0gXCJudW1iZXJcIiAmJiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiAhPT0gb3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubWlncmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWlncmF0ZShcbiAgICAgICAgICAgICAgZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlLnN0YXRlLFxuICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBTdGF0ZSBsb2FkZWQgZnJvbSBzdG9yYWdlIGNvdWxkbid0IGJlIG1pZ3JhdGVkIHNpbmNlIG5vIG1pZ3JhdGUgZnVuY3Rpb24gd2FzIHByb3ZpZGVkYFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLnRoZW4oKG1pZ3JhdGVkU3RhdGUpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBzdGF0ZUZyb21TdG9yYWdlID0gb3B0aW9ucy5tZXJnZShcbiAgICAgICAgbWlncmF0ZWRTdGF0ZSxcbiAgICAgICAgKF9hMiA9IGdldCgpKSAhPSBudWxsID8gX2EyIDogY29uZmlnUmVzdWx0XG4gICAgICApO1xuICAgICAgc2V0KHN0YXRlRnJvbVN0b3JhZ2UsIHRydWUpO1xuICAgICAgcmV0dXJuIHNldEl0ZW0oKTtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayhzdGF0ZUZyb21TdG9yYWdlLCB2b2lkIDApO1xuICAgICAgaGFzSHlkcmF0ZWQgPSB0cnVlO1xuICAgICAgZmluaXNoSHlkcmF0aW9uTGlzdGVuZXJzLmZvckVhY2goKGNiKSA9PiBjYihzdGF0ZUZyb21TdG9yYWdlKSk7XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayh2b2lkIDAsIGUpO1xuICAgIH0pO1xuICB9O1xuICBhcGkucGVyc2lzdCA9IHtcbiAgICBzZXRPcHRpb25zOiAobmV3T3B0aW9ucykgPT4ge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ubmV3T3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGlmIChuZXdPcHRpb25zLmdldFN0b3JhZ2UpIHtcbiAgICAgICAgc3RvcmFnZSA9IG5ld09wdGlvbnMuZ2V0U3RvcmFnZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xlYXJTdG9yYWdlOiAoKSA9PiB7XG4gICAgICBzdG9yYWdlID09IG51bGwgPyB2b2lkIDAgOiBzdG9yYWdlLnJlbW92ZUl0ZW0ob3B0aW9ucy5uYW1lKTtcbiAgICB9LFxuICAgIGdldE9wdGlvbnM6ICgpID0+IG9wdGlvbnMsXG4gICAgcmVoeWRyYXRlOiAoKSA9PiBoeWRyYXRlKCksXG4gICAgaGFzSHlkcmF0ZWQ6ICgpID0+IGhhc0h5ZHJhdGVkLFxuICAgIG9uSHlkcmF0ZTogKGNiKSA9PiB7XG4gICAgICBoeWRyYXRpb25MaXN0ZW5lcnMuYWRkKGNiKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGh5ZHJhdGlvbkxpc3RlbmVycy5kZWxldGUoY2IpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIG9uRmluaXNoSHlkcmF0aW9uOiAoY2IpID0+IHtcbiAgICAgIGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycy5hZGQoY2IpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZmluaXNoSHlkcmF0aW9uTGlzdGVuZXJzLmRlbGV0ZShjYik7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgaHlkcmF0ZSgpO1xuICByZXR1cm4gc3RhdGVGcm9tU3RvcmFnZSB8fCBjb25maWdSZXN1bHQ7XG59O1xuY29uc3QgbmV3SW1wbCA9IChjb25maWcsIGJhc2VPcHRpb25zKSA9PiAoc2V0LCBnZXQsIGFwaSkgPT4ge1xuICBsZXQgb3B0aW9ucyA9IHtcbiAgICBzdG9yYWdlOiBjcmVhdGVKU09OU3RvcmFnZSgoKSA9PiBsb2NhbFN0b3JhZ2UpLFxuICAgIHBhcnRpYWxpemU6IChzdGF0ZSkgPT4gc3RhdGUsXG4gICAgdmVyc2lvbjogMCxcbiAgICBtZXJnZTogKHBlcnNpc3RlZFN0YXRlLCBjdXJyZW50U3RhdGUpID0+ICh7XG4gICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICAuLi5wZXJzaXN0ZWRTdGF0ZVxuICAgIH0pLFxuICAgIC4uLmJhc2VPcHRpb25zXG4gIH07XG4gIGxldCBoYXNIeWRyYXRlZCA9IGZhbHNlO1xuICBjb25zdCBoeWRyYXRpb25MaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgc3RvcmFnZSA9IG9wdGlvbnMuc3RvcmFnZTtcbiAgaWYgKCFzdG9yYWdlKSB7XG4gICAgcmV0dXJuIGNvbmZpZyhcbiAgICAgICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgW3p1c3RhbmQgcGVyc2lzdCBtaWRkbGV3YXJlXSBVbmFibGUgdG8gdXBkYXRlIGl0ZW0gJyR7b3B0aW9ucy5uYW1lfScsIHRoZSBnaXZlbiBzdG9yYWdlIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZS5gXG4gICAgICAgICk7XG4gICAgICAgIHNldCguLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBnZXQsXG4gICAgICBhcGlcbiAgICApO1xuICB9XG4gIGNvbnN0IHNldEl0ZW0gPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBvcHRpb25zLnBhcnRpYWxpemUoeyAuLi5nZXQoKSB9KTtcbiAgICByZXR1cm4gc3RvcmFnZS5zZXRJdGVtKG9wdGlvbnMubmFtZSwge1xuICAgICAgc3RhdGUsXG4gICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb25cbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc2F2ZWRTZXRTdGF0ZSA9IGFwaS5zZXRTdGF0ZTtcbiAgYXBpLnNldFN0YXRlID0gKHN0YXRlLCByZXBsYWNlKSA9PiB7XG4gICAgc2F2ZWRTZXRTdGF0ZShzdGF0ZSwgcmVwbGFjZSk7XG4gICAgdm9pZCBzZXRJdGVtKCk7XG4gIH07XG4gIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IGNvbmZpZyhcbiAgICAoLi4uYXJncykgPT4ge1xuICAgICAgc2V0KC4uLmFyZ3MpO1xuICAgICAgdm9pZCBzZXRJdGVtKCk7XG4gICAgfSxcbiAgICBnZXQsXG4gICAgYXBpXG4gICk7XG4gIGFwaS5nZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBjb25maWdSZXN1bHQ7XG4gIGxldCBzdGF0ZUZyb21TdG9yYWdlO1xuICBjb25zdCBoeWRyYXRlID0gKCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFzdG9yYWdlKSByZXR1cm47XG4gICAgaGFzSHlkcmF0ZWQgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25MaXN0ZW5lcnMuZm9yRWFjaCgoY2IpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gY2IoKF9hMiA9IGdldCgpKSAhPSBudWxsID8gX2EyIDogY29uZmlnUmVzdWx0KTtcbiAgICB9KTtcbiAgICBjb25zdCBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayA9ICgoX2IgPSBvcHRpb25zLm9uUmVoeWRyYXRlU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucywgKF9hID0gZ2V0KCkpICE9IG51bGwgPyBfYSA6IGNvbmZpZ1Jlc3VsdCkpIHx8IHZvaWQgMDtcbiAgICByZXR1cm4gdG9UaGVuYWJsZShzdG9yYWdlLmdldEl0ZW0uYmluZChzdG9yYWdlKSkob3B0aW9ucy5uYW1lKS50aGVuKChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpID0+IHtcbiAgICAgIGlmIChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiA9PT0gXCJudW1iZXJcIiAmJiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiAhPT0gb3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubWlncmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgb3B0aW9ucy5taWdyYXRlKFxuICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS5zdGF0ZSxcbiAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFN0YXRlIGxvYWRlZCBmcm9tIHN0b3JhZ2UgY291bGRuJ3QgYmUgbWlncmF0ZWQgc2luY2Ugbm8gbWlncmF0ZSBmdW5jdGlvbiB3YXMgcHJvdmlkZWRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW2ZhbHNlLCBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUuc3RhdGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW2ZhbHNlLCB2b2lkIDBdO1xuICAgIH0pLnRoZW4oKG1pZ3JhdGlvblJlc3VsdCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGNvbnN0IFttaWdyYXRlZCwgbWlncmF0ZWRTdGF0ZV0gPSBtaWdyYXRpb25SZXN1bHQ7XG4gICAgICBzdGF0ZUZyb21TdG9yYWdlID0gb3B0aW9ucy5tZXJnZShcbiAgICAgICAgbWlncmF0ZWRTdGF0ZSxcbiAgICAgICAgKF9hMiA9IGdldCgpKSAhPSBudWxsID8gX2EyIDogY29uZmlnUmVzdWx0XG4gICAgICApO1xuICAgICAgc2V0KHN0YXRlRnJvbVN0b3JhZ2UsIHRydWUpO1xuICAgICAgaWYgKG1pZ3JhdGVkKSB7XG4gICAgICAgIHJldHVybiBzZXRJdGVtKCk7XG4gICAgICB9XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2soc3RhdGVGcm9tU3RvcmFnZSwgdm9pZCAwKTtcbiAgICAgIHN0YXRlRnJvbVN0b3JhZ2UgPSBnZXQoKTtcbiAgICAgIGhhc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgICAgIGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycy5mb3JFYWNoKChjYikgPT4gY2Ioc3RhdGVGcm9tU3RvcmFnZSkpO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2sodm9pZCAwLCBlKTtcbiAgICB9KTtcbiAgfTtcbiAgYXBpLnBlcnNpc3QgPSB7XG4gICAgc2V0T3B0aW9uczogKG5ld09wdGlvbnMpID0+IHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLm5ld09wdGlvbnNcbiAgICAgIH07XG4gICAgICBpZiAobmV3T3B0aW9ucy5zdG9yYWdlKSB7XG4gICAgICAgIHN0b3JhZ2UgPSBuZXdPcHRpb25zLnN0b3JhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhclN0b3JhZ2U6ICgpID0+IHtcbiAgICAgIHN0b3JhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3JhZ2UucmVtb3ZlSXRlbShvcHRpb25zLm5hbWUpO1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uczogKCkgPT4gb3B0aW9ucyxcbiAgICByZWh5ZHJhdGU6ICgpID0+IGh5ZHJhdGUoKSxcbiAgICBoYXNIeWRyYXRlZDogKCkgPT4gaGFzSHlkcmF0ZWQsXG4gICAgb25IeWRyYXRlOiAoY2IpID0+IHtcbiAgICAgIGh5ZHJhdGlvbkxpc3RlbmVycy5hZGQoY2IpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaHlkcmF0aW9uTGlzdGVuZXJzLmRlbGV0ZShjYik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgb25GaW5pc2hIeWRyYXRpb246IChjYikgPT4ge1xuICAgICAgZmluaXNoSHlkcmF0aW9uTGlzdGVuZXJzLmFkZChjYik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBpZiAoIW9wdGlvbnMuc2tpcEh5ZHJhdGlvbikge1xuICAgIGh5ZHJhdGUoKTtcbiAgfVxuICByZXR1cm4gc3RhdGVGcm9tU3RvcmFnZSB8fCBjb25maWdSZXN1bHQ7XG59O1xuY29uc3QgcGVyc2lzdEltcGwgPSAoY29uZmlnLCBiYXNlT3B0aW9ucykgPT4ge1xuICBpZiAoXCJnZXRTdG9yYWdlXCIgaW4gYmFzZU9wdGlvbnMgfHwgXCJzZXJpYWxpemVcIiBpbiBiYXNlT3B0aW9ucyB8fCBcImRlc2VyaWFsaXplXCIgaW4gYmFzZU9wdGlvbnMpIHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbREVQUkVDQVRFRF0gYGdldFN0b3JhZ2VgLCBgc2VyaWFsaXplYCBhbmQgYGRlc2VyaWFsaXplYCBvcHRpb25zIGFyZSBkZXByZWNhdGVkLiBVc2UgYHN0b3JhZ2VgIG9wdGlvbiBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb2xkSW1wbChjb25maWcsIGJhc2VPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbmV3SW1wbChjb25maWcsIGJhc2VPcHRpb25zKTtcbn07XG5jb25zdCBwZXJzaXN0ID0gcGVyc2lzdEltcGw7XG5cbmV4cG9ydCB7IGNvbWJpbmUsIGNyZWF0ZUpTT05TdG9yYWdlLCBkZXZ0b29scywgcGVyc2lzdCwgcmVkdXgsIHN1YnNjcmliZVdpdGhTZWxlY3RvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs":
/*!**********************************************!*\
  !*** ./node_modules/zustand/esm/vanilla.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: function() { return /* binding */ createStore; },\n/* harmony export */   \"default\": function() { return /* binding */ vanilla; }\n/* harmony export */ });\nconst createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if (( false ? 0 : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS92YW5pbGxhLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThIO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFlLEdBQUcsQ0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUUyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdmFuaWxsYS5tanM/YTBmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjcmVhdGVTdG9yZUltcGwgPSAoY3JlYXRlU3RhdGUpID0+IHtcbiAgbGV0IHN0YXRlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBzZXRTdGF0ZSA9IChwYXJ0aWFsLCByZXBsYWNlKSA9PiB7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09IFwiZnVuY3Rpb25cIiA/IHBhcnRpYWwoc3RhdGUpIDogcGFydGlhbDtcbiAgICBpZiAoIU9iamVjdC5pcyhuZXh0U3RhdGUsIHN0YXRlKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xuICAgICAgc3RhdGUgPSAocmVwbGFjZSAhPSBudWxsID8gcmVwbGFjZSA6IHR5cGVvZiBuZXh0U3RhdGUgIT09IFwib2JqZWN0XCIgfHwgbmV4dFN0YXRlID09PSBudWxsKSA/IG5leHRTdGF0ZSA6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihzdGF0ZSwgcHJldmlvdXNTdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiBzdGF0ZTtcbiAgY29uc3QgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gaW5pdGlhbFN0YXRlO1xuICBjb25zdCBzdWJzY3JpYmUgPSAobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH07XG4gIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW0RFUFJFQ0FURURdIFRoZSBgZGVzdHJveWAgbWV0aG9kIHdpbGwgYmUgdW5zdXBwb3J0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gSW5zdGVhZCB1c2UgdW5zdWJzY3JpYmUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgc3Vic2NyaWJlLiBFdmVyeXRoaW5nIHdpbGwgYmUgZ2FyYmFnZS1jb2xsZWN0ZWQgaWYgc3RvcmUgaXMgZ2FyYmFnZS1jb2xsZWN0ZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICB9O1xuICBjb25zdCBhcGkgPSB7IHNldFN0YXRlLCBnZXRTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBzdWJzY3JpYmUsIGRlc3Ryb3kgfTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gc3RhdGUgPSBjcmVhdGVTdGF0ZShzZXRTdGF0ZSwgZ2V0U3RhdGUsIGFwaSk7XG4gIHJldHVybiBhcGk7XG59O1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoY3JlYXRlU3RhdGUpID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlU3RvcmVJbXBsKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0b3JlSW1wbDtcbnZhciB2YW5pbGxhID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0RFUFJFQ0FURURdIERlZmF1bHQgZXhwb3J0IGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAnenVzdGFuZC92YW5pbGxhJy5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlLCB2YW5pbGxhIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/zustand/esm/vanilla.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5Cam112%5C%5COneDrive%5C%5C%D8%B3%D8%B7%D8%AD%20%D8%A7%D9%84%D9%85%D9%83%D8%AA%D8%A8%5C%5CClients%5C%5CMBTI%5C%5Csrc%5C%5Capp%5C%5C%5Blocale%5D%5C%5Cassessment%5C%5Cresults%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);